#! /bin/bash

QUIET="y"
FORCE="n"
export LABEL="ARCH_$(date +%Y%m)"
PUBLISHER="Arch Linux <http://www.archlinux.org>"
APPLICATION="Arch Linux Live/Rescue CD"
CREATE_DEFAULT="n"
PROFILE=$(pwd)
ver=""
CDNAME="archiso-live"
RMSTUFF=n
MVSTUFF=n
EXT="sqfs"
MKOPTION="-b 256k"
MODULES=""
modlocale="z.099.locale"
modmove="z.099.etc"

error () { echo -e "\033[1;31;40m!!! \033[1;37;40m$@\033[1;0m"; }
warn ()  { echo -e "\033[1;33;40m*** \033[1;37;40m$@\033[1;0m"; }
info () { echo -e "\033[1;32;40m>>> \033[1;37;40m$@\033[1;0m"; }

APPNAME=$(basename "${0}")

# usage: usage <exitvalue>
usage ()
{
    echo "usage ${APPNAME} [options] command <command options>"
    echo " general options:"
    echo "    -f                Force overwrite of working files/squashfs image/bootable image"
    echo "    -p <profile>      Profile of working configs for iso. Default $PROFILE"
    echo "    -C <file>         Config file for pacman. Default $PACCONFIG"
    echo "    -m <base_modules> Squashfs base folder modules of iso."
    echo "    -L <label>        Set a label for the disk"
    echo "    -P <publisher>    Set a publisher for the disk"
    echo "    -A <application>  Set an application name for the disk"
    echo "    -d                Create default user directory /home/arch"
    echo "    -v                Enable verbose output"
    echo "    -h                This message"
    echo " commands:"
    echo "   create <dir>"
    echo "      create a base directory layout to work with"
    echo "      includes all specified packages"
    echo "   iso <dir> <image name>"
    echo "      build an iso image from the working dir"
    echo "   all <dir> <image name>"
    echo "      create base folder and iso in one command"
    exit $1
}

while getopts 'p:C:m:L:P:A:dfvh' arg; do
    case "${arg}" in
        p) PROFILE="${OPTARG}" ;;
        C) PACCONFIG="${OPTARG}" ;;
    	L) LABEL="${OPTARG}" ;;
        m) BASE_MODULES="${OPTARG}" ;;
    	P) PUBLISHER="${OPTARG}" ;;
    	A) APPLICATION="${OPTARG}" ;;
        d) CREATE_DEFAULT="y" ;;
        f) FORCE="y" ;;
        v) QUIET="n" ;;
        h|?) usage 0 ;;
        *) echo "invalid argument '${arg}'"; usage 1 ;;
    esac
done

shift $(($OPTIND - 1))

# do UID checking here so someone can at least get usage instructions
if [ "$EUID" != "0" ]; then
    error "error: This script must be run as root."
    exit 1
fi

if [ -f ${PROFILE}/config ]; then
	source ${PROFILE}/config
fi

VMLINUZ="boot/vmlinuz26${ver}"
MAP26="boot/System.map26${ver}"
KERNEL="/etc/mkinitcpio.d/kernel26${ver}.kver"
ROOT_MOD="$(ls -1 ${PROFILE}/list | head -1)"
CPIOCONFIG="${PROFILE}/mkinitcpio.conf"

if [ -f "${PROFILE}/pacman.conf" ]; then
    PACCONFIG="${PROFILE}/pacman.conf"
else
    if [ -f "/etc/pacman.conf" ]; then
        PACCONFIG="/etc/pacman.conf"
    elif [ ! -f "$PACCONFIG" ]; then
        error "error: pacman config file '$PACCONFIG' does not exist"
        exit 1
    fi
fi

command_name="${1}"
work_dir=""
imgname=""

case "${command_name}" in
    create) work_dir="${2}"; imgname="none" ;;
    iso) work_dir="${2}"; imgname="${3}" ;;
    all) work_dir="${2}"; imgname="${3}" ;;
    *) echo "invalid command name '${command_name}'"; usage 1 ;;
esac

[ "x${imgname}" = "x" ] && warn "Image name must be specified" && usage 1
[ "x${work_dir}" = "x" ] && warn "Please specify a working directory" && usage 1

rootimg_dir="${work_dir}/root-image" # union folder
iso_dir="${work_dir}/iso" # iso folder
isobasemod_dir="${work_dir}/iso/${CDNAME}/base" # place to put squashfs images of modules for union
isomodules_dir="${work_dir}/iso/${CDNAME}/modules"
modules_dir="${work_dir}/modules" # make modules in here
lastbr_dir="${work_dir}/empty"
INSTROOT="${modules_dir}/$(basename ${ROOT_MOD} .list)"
sync_dir="${work_dir}/empty"
sgn_file="${iso_dir}/${CDNAME}/livecd.sgn"

if [ "${MODULES}" != "" ]; then
    UNION_MODULES="${BASE_MODULES} ${MODULES}"
elif [ "${MODULES}" = "" ]; then
    UNION_MODULES="${BASE_MODULES}"
fi

echo "${APPNAME} : Configuration Settings"
echo "        working directory:   ${work_dir}"
echo "               image name:   ${imgname}"
echo "            pacman config:   ${PACCONFIG}"

# usage: _pacman <packages>...
_pacman ()
{
    local ret
    if [ "${QUIET}" = "y" ]; then
        mkarchroot -C "$PACCONFIG" -f "$rootimg_dir" $* 2>&1 >/dev/null
        ret=$?
    else
        mkarchroot -C "$PACCONFIG" -f "$rootimg_dir" $*
        ret=$?
    fi

    # Cleanup
    find "${work_dir}" -name *.pacnew -name *.pacsave -name *.pacorig -delete

    if [ $ret -ne 0 ]; then
        exit 1
    fi
}

_kversion ()
{
    if [ -f ${INSTROOT}${KERNEL} ]; then
        source ${INSTROOT}${KERNEL}
        echo ${ALL_kver}
    else
        echo ${ALL_kver}
    fi
}

_bootfiles () {
    mkdir -p ${iso_dir}/boot/isolinux
    if [ -f ${INSTROOT}/${MAP26} ]; then
        mv -f ${INSTROOT}/${MAP26} ${iso_dir}/${MAP26}
    fi
    if [ -f ${INSTROOT}/${VMLINUZ} ]; then
        mv -f ${INSTROOT}/${VMLINUZ} ${iso_dir}/boot/vmlinuz
    fi
    cp -f ${INSTROOT}/boot/memtest86+/memtest.bin ${iso_dir}/boot/memtest
    cp -f ${INSTROOT}/usr/share/licenses/common/GPL2/license.txt ${iso_dir}/boot/memtest.COPYING
    cp -rf ${PROFILE}/boot-files/* ${iso_dir}/boot/
    cp -f ${INSTROOT}/usr/lib/syslinux/*.c32 ${iso_dir}/boot/isolinux/
    cp -f ${INSTROOT}/usr/lib/syslinux/isolinux.bin ${iso_dir}/boot/isolinux/
    cp -f ${INSTROOT}/usr/lib/syslinux/memdisk ${iso_dir}/boot/isolinux/
    cp -f ${INSTROOT}/usr/lib/syslinux/pxelinux.0 ${iso_dir}/boot/isolinux/
    cp -f ${INSTROOT}/usr/lib/syslinux/gpxelinux.0 ${iso_dir}/boot/isolinux/
}

_overlay() {

    if [ -d ${modules_dir}/overlay ]; then
        rm -Rf ${modules_dir}/overlay
        cp -rf ${PROFILE}/overlay ${modules_dir}
    else
        cp -rf ${PROFILE}/overlay ${modules_dir}
    fi

    if [ ${CREATE_DEFAULT} == "y" ]; then
        if [ -d "${modules_dir}/overlay/home/" ]; then
            info "Creating default home directory"
            install -d -o1000 -g100 -m0755 "${modules_dir}/overlay/home/arch"
        fi
    fi

    if [ "${QUIET}" = "y" ]; then
        mksquashfs "${modules_dir}/overlay" "${iso_dir}/${CDNAME}/optional/overlay.${EXT}" -noappend ${MKOPTION} >/dev/null
    else
        mksquashfs "${modules_dir}/overlay" "${iso_dir}/${CDNAME}/optional/overlay.${EXT}" -noappend ${MKOPTION}
    fi

}

_mkinitramfs()
{
    info "Making bootable image"

    if [ -e "${imgname}" ]; then
        if [ "${FORCE}" = "y" ]; then
            info "Removing existing bootable image..."
            rm -rf "${imgname}"
        else
            error "error: Image '${imgname}' already exists, aborting."
            exit 1
        fi
    fi
    if [ ! -e "${CPIOCONFIG}" ]; then
        error "error: mkinitcpio config '${CPIOCONFIG}' does not exist, aborting."
        exit 1
    fi

    info "Generating initcpio for image..."
    if [ "${QUIET}" = "y" ]; then
        #mkinitcpio -c "${CPIOCONFIG}" -k "${kernelver}" -g "${IMGROOT}/boot/initrd.img" >/dev/null
        mkinitcpio $1 $2 $3 $4 $5 $6 $7 $8 > /dev/null
        ret=$?
    else
        #mkinitcpio -c "${CPIOCONFIG}" -k "${kernelver}" -g "${IMGROOT}/boot/initrd.img"
        mkinitcpio $1 $2 $3 $4 $5 $6 $7 $8
        ret=$?
    fi
    if [ $ret -ne 0 ]; then
        error "error: initcpio image creation failed..."
        exit 1
    fi
}

# Finally, make the image.
_imgprepare () {
    kernelver=$(_kversion)
    basedir=${INSTROOT}
    [ "${INSTROOT:0:1}" != "/" ] && basedir="$(pwd)/${INSTROOT}"
    _mkinitramfs -c "${CPIOCONFIG}" -b "${basedir}" -k "${kernelver}" -g "${iso_dir}/boot/initrd.img"
}

_rmstuff () {
    if [ "${RMSTUFF}" = "y" ]; then
        for m in ${UNION_MODULES}; do
            if [ -f "${PROFILE}/list/rmlocale" ]; then
                cat "${PROFILE}/list/rmlocale" | grep -v "^#" | while read rmlocale; do
                    if [ -d "${modules_dir}/${m}/usr/share/locale/${rmlocale}" ]; then
                        info "Removing locale $rmlocale from ${m}"
                        rm -Rf ${modules_dir}/${m}/usr/share/locale/${rmlocale}
                    fi
                done
            fi

            if [ -f "${PROFILE}/list/remove" ]; then
                cat "${PROFILE}/list/remove" | grep -v "^#" | while read remove; do
                    if [ -e "${modules_dir}/${m}/${remove}" ]; then
                        info "Removing $remove from ${m}"
                        rm -Rf ${modules_dir}/${m}/${remove}
                    fi
                done
            fi
            info "Removing .pyc files from ${m}"
            RMPYC=$(find ${modules_dir}/${m}/ -name "*.pyc")
            rm -Rf ${RMPYC}
            info "Uncompressing .gz files in ${m}"
            find -H ${modules_dir}/${m}/ -name "*.gz" -exec gunzip -qf {} \; 2>/dev/null
            if [ -f ${modules_dir}/${m}/usr/share/fonts/misc/fonts.dir ]; then
                sed -i "s|.pcf.gz|.pcf|g" ${modules_dir}/${m}/usr/share/fonts/misc/fonts.dir
            fi
        done
    fi
}

_mvstuff () {
    if [ "${MVSTUFF}" = "y" ]; then
        for m in ${BASE_MODULES}; do
            if [ -f "${PROFILE}/list/mvlocate" ]; then
                cat "${PROFILE}/list/mvlocale" | grep -v "^#" | while read mvlocale; do
                    if [ -d "${modules_dir}/${m}/usr/share/locale/${mvlocale}" ]; then
                        info "Moving locale ${mvlocale} from ${m} to ${modlocale}"
                        mkdir -p ${modules_dir}/${modlocale}/usr/share/locale
                        mv -f ${modules_dir}/${m}/usr/share/locale/${mvlocale} ${modules_dir}/${modlocale}/usr/share/locale
                    fi
                done
            fi
            if [ -f "${PROFILE}/list/move" ]; then
                cat "${PROFILE}/list/move" | grep -v "^#" | while read move; do
                    if [ -d "${modules_dir}/${m}/${move}" ]; then
                        info "Moving $move from ${m} to ${modmove}"
                        move_dir=$(dirname ${move})
                            if [ ! -d ${modules_dir}/${modmove}/${move_dir} ]; then
                                mkdir -p ${modules_dir}/${modmove}/${move_dir}
                            fi
                        cp -a ${modules_dir}/${m}/${move} ${modules_dir}/${modmove}/${move_dir}
                        rm -Rf ${modules_dir}/${m}/${move}
                    fi
                    info "Moving .a files from ${m} to ${modmove}"
                    if [ ! -d ${modules_dir}/${modmove}/usr/lib ]; then
                        mkdir -p ${modules_dir}/${modmove}/usr/lib
                    fi
                    find ${modules_dir}/${m}/usr/lib -maxdepth 1 -name "*.*a" -exec cp -af {} ${modules_dir}/${modmove}/usr/lib \;
                    find ${modules_dir}/${m}/usr/lib -maxdepth 1 -name "*.*a" -exec rm -f {} \;
                done
            fi
        done
    fi
}

command_create () {
    info "====> Creating working directory: ${work_dir}"
    mkdir -p "${iso_dir}"
    mkdir -p "${rootimg_dir}"
    #mkdir -p "${isomodules_dir}"
    mkdir -p ${iso_dir}/${CDNAME}/{base,modules,optional,rootcopy,tmp}
    mkdir -p "${modules_dir}"
    mkdir -p "${lastbr_dir}"
    touch ${sgn_file}

    echo "README for this archiso created directory

All directories in this dir, except for 'iso' will be squashed
with squashfs and put into the iso dir as iso/${CDNAME}/base/<dirname>.${EXT}
The squashfs images will be auto detected on boot.

The iso dir is later used to build the actual bootable iso.
Please ensure the proper bootloader is installed or copied
to the iso/ directory.

...TODO: Write more..." > "${work_dir}/README"

    modprobe aufs
    if [ $? -ne 0 ]; then
	error "Error loading Union filesystem module. (aufs)"
        exit 1
    fi

    mount -t aufs -o br:${lastbr_dir}=rw aufs ${rootimg_dir}
    if [ $? -ne 0 ]; then 
        error "Error mounting $union."
        exit 1
    fi

    # in case of if you have to kill mkarchiso cause of something
    if [ -d "${sync_dir}/var/lib/pacman" ]; then
        # Delete pacman database sync cache files (*.tar.gz)
        find "${sync_dir}/var/lib/pacman" -maxdepth 1 -type f -delete
        # Delete pacman database sync cache
        find "${sync_dir}/var/lib/pacman/sync" -delete
    fi

    if [ -e "${sync_dir}/var/lib/pacman/db.lck" ]; then
        rm -f ${sync_dir}/var/lib/pacman/db.lck
    fi

    info "====> Installing packages to '${rootimg_dir}'"
    for mod in ${UNION_MODULES}; do
        if [ ! -d ${modules_dir}/${mod} ]; then
            mkdir -p ${modules_dir}/${mod}
        fi
        info "Adding ${modules_dir}/${mod} as top branch of union."
        mount -t aufs -o remount,add:0:${modules_dir}/${mod}=rw aufs ${rootimg_dir}
        info "Adding ${lastbr_dir} as lower branch of union."
        mount -t aufs -o remount,mod:${lastbr_dir}=rr+wh aufs ${rootimg_dir}
        lastbr_dir="${modules_dir}/${mod}"

        if [ ! -d "${sync_dir}/var/lib/pacman/sync/core" ]; then
	    mkdir -p ${sync_dir}/var/lib/pacman
            pacman -Sy --noprogressbar --noconfirm --config "${PACCONFIG}" -fr "${sync_dir}"
            if [ -d ${sync_dir}/var/lib/pacman/local ]; then
                rmdir --ignore-fail-on-non-empty ${sync_dir}/var/lib/pacman/local
            fi
        fi
        
        if [ -d ${modules_dir}/${mod}/var/lib/pacman/local ]; then
            #mkarchroot -C "$PACCONFIG" -f -u ${rootimg_dir}
            pacman -Su -f --needed --noconfirm --config "${PACCONFIG}" -fr "${rootimg_dir}"
        elif [ ! -d ${modules_dir}/${mod}/var/lib/pacman/local ]; then
            if [ -e "${PROFILE}/list/${mod}.list" ]; then
                cat "${PROFILE}/list/${mod}.list" | grep -v "^#" | while read pkgname; do
                    #_pacman "${pkgname}"
                    info "Installing package $pkgname"
                    mkarchroot -C "$PACCONFIG" -f ${rootimg_dir} "$pkgname"
                done
            fi

            if [ -e "${PROFILE}/list/${mod}.removelist" ]; then
                cat "${PROFILE}/list/${mod}.removelist" | grep -v "^#" | while read pkgname; do
                    info "Removing package $pkgname"
                    pacman -R -d -n --noprogressbar --needed --noconfirm --config "$PACCONFIG" -r "$rootimg_dir" $pkgname
                done
            fi
        fi

    # Delete all log files, keeps empty dirs.
    find "${work_dir}/${mod}/var/log" -type f -delete

    # Delete all temporary files and dirs
    find "${work_dir}/${mod}/var/tmp" -mindepth 1 -delete

    done

    info "Making package list"
    pacman -Q -r ${rootimg_dir} > ${iso_dir}/packages.list

    info "Unmounting union"
    umount -l "${rootimg_dir}"

    info "Moving stuff"
    _mvstuff

    info "Removing stuff"
    _rmstuff

    info "Cleaning up what we can"

    find "${modules_dir}" -name *.pacnew -name *.pacsave -name *.pacorig -delete

    info "Removing unionfs .wh. files."
    find ${modules_dir} -type f -name ".wh.*" -exec rm {} \;
    find ${modules_dir} -type d -name ".wh.*" -exec rm -rf {} \;

    if [ -d "${INSTROOT}/boot/" ]; then
        # remove the initcpio images that were generated for the host system
        find "${INSTROOT}/boot" -name '*.img' -delete
    fi

    # delete a lot of unnecessary cache/log files
    kill_dirs="var/abs var/cache/man var/cache/pacman var/lib/pacman/sync var/log/* var/mail tmp/* initrd"
    for x in ${kill_dirs}; do
        if [ -e "${rootimg_dir}/${x}" ]; then
            rm -rf "${rootimg_dir}/${x}"
        fi
    done 

}

# _mksquash dirname
_mksquash () {
    if [ ! -d "$1" ]; then
        error "Error: '$1' is not a directory"
        return 1
    fi

    if [ ! -d "$2" ]; then
        error "Error: '$2' is not a directory"
        return 1
    fi

    time_dir=/var/lib/pacman/local
    sqimg="${2}/$(basename ${1}).${EXT}"
    info "====> Generating SquashFS image for '${1}'"
    if [ -e "${sqimg}" ]; then
        dirhaschanged=$(find ${1}${time_dir} -newer ${sqimg})
        if [ "${dirhaschanged}" != "" ]; then
            info "SquashFS image '${sqimg}' is not up to date, rebuilding..."
            rm "${sqimg}"
        else
            info "SquashFS image '${sqimg}' is up to date, skipping."
            return
        fi
    fi

    info "Creating SquashFS image. This may take some time..."
    start=$(date +%s)
    if [ "${QUIET}" = "y" ]; then
        mksquashfs "${1}" "${sqimg}" -noappend ${MKOPTION} >/dev/null
    else
        mksquashfs "${1}" "${sqimg}" -noappend ${MKOPTION}
    fi
    minutes=$(echo $start $(date +%s) | awk '{ printf "%0.2f",($2-$1)/60 }')
    info "Image creation done in $minutes minutes."
}

_imgcommon () {
    for m in ${BASE_MODULES}; do
        if [ -d "${modules_dir}/$m" ]; then
            _mksquash "${modules_dir}/$m" "${isobasemod_dir}"
        fi
    done

    if [ "${MODULES}" != "" ]; then
        for MOD in ${MODULES}; do
            if [ -d "${modules_dir}/${MOD}" ]; then
                _mksquash "${modules_dir}/${MOD}" "${isomodules_dir}"
            fi
        done
    fi
    
    if [ "${MVSTUFF}" = "y" ]; then
       if [ -d "${modules_dir}/${modlocale}" ]; then
           _mksquash "${modules_dir}/${modlocale}" "${isomodules_dir}"
       fi

       if [ -d "${modules_dir}/${modmove}" ]; then
          _mksquash "${modules_dir}/${modmove}" "${isomodules_dir}"
       fi
    fi

    info "====> Making bootable image"

    # Sanity checks
    if [ ! -d "${iso_dir}" ]; then
        error "Error: '${iso_dir}' doesn't exist. What did you do?!"
        exit 1
    fi

    if [ ! -f "${sgn_file}" ]; then
        error "Error: the ${sgn_file} file doesn't exist. This image won't do anything"
        error "  Protecting you from yourself and erroring out here..."
        exit 1
    fi

    if [ -e "${imgname}" ]; then
        if [ "${FORCE}" = "y" ]; then
            info "Removing existing bootable image..."
            rm -rf "${imgname}"
        else
            error "Error: Image '${imgname}' already exists, aborting."
            exit 1
        fi
    fi
}

command_iso () {
    _bootfiles
    if [ -d ${PROFILE}/overlay ]; then
        _overlay
    fi
    _imgcommon
    _imgprepare

    info "Creating ISO image..."
    qflag=""
    [ "${QUIET}" = "y" ] && qflag="-quiet"
    mkisofs ${qflag} -r -l \
        -b boot/isolinux/isolinux.bin -c boot/isolinux/boot.cat \
        -uid 0 -gid 0 \
        -udf -allow-limited-size -iso-level 3 \
        -input-charset utf-8 -p "prepared by mkarchiso" \
        -no-emul-boot -boot-load-size 4 -boot-info-table \
        -publisher "${PUBLISHER}" \
        -A "${APPLICATION}" \
        -V "${LABEL}" \
        -o "${imgname}" "${iso_dir}"
    isohybrid "${imgname}"
    md5sum "${imgname}" > "${imgname}".md5
}

# Go through the main commands in order. If 'all' was specified, then we want
# to do everything. Start with 'install'.
if [ "${command_name}" = "create" -o "${command_name}" = "all" ]; then
    command_create
fi
if [ "${command_name}" = "iso" -o "${command_name}" = "all" ]; then
    command_iso
fi

# vim:ts=4:sw=4:et:
