diff -aurN squashfs4.1.old/squashfs-tools/compressor.c squashfs4.1.new/squashfs-tools/compressor.c
--- squashfs4.1.old/squashfs-tools/compressor.c	2010-09-14 16:39:40.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/compressor.c	2010-12-28 06:00:19.000000000 +0000
@@ -25,31 +25,52 @@
 #include "compressor.h"
 #include "squashfs_fs.h"
 
-extern int gzip_compress(void **, char *, char *, int, int, int *);
-extern int gzip_uncompress(char *, char *, int, int, int *);
-extern int lzma_compress(void **, char *, char *, int, int, int *);
-extern int lzma_uncompress(char *, char *, int, int, int *);
-extern int lzo_compress(void **, char *, char *, int, int, int *);
-extern int lzo_uncompress(char *, char *, int, int, int *);
-
-struct compressor compressor[] = {
-#ifdef GZIP_SUPPORT
-	{ gzip_compress, gzip_uncompress, ZLIB_COMPRESSION, "gzip", 1 },
+#ifndef GZIP_SUPPORT
+static struct compressor gzip_comp_ops =  {
+	NULL, NULL, NULL, NULL, NULL, NULL, ZLIB_COMPRESSION, "gzip", 0
+};
+#else
+extern struct compressor gzip_comp_ops;
+#endif
+
+#ifndef LZMA_SUPPORT
+static struct compressor lzma_comp_ops = {
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, LZMA_COMPRESSION,
+	"lzma", 0
+};
 #else
-	{ NULL, NULL, ZLIB_COMPRESSION, "gzip", 0 },
+extern struct compressor lzma_comp_ops;
 #endif
-#ifdef LZMA_SUPPORT
-	{ lzma_compress, lzma_uncompress, LZMA_COMPRESSION, "lzma", 1 },
+
+#ifndef LZO_SUPPORT
+static struct compressor lzo_comp_ops = {
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, LZO_COMPRESSION, "lzo",
+	0
+};
 #else
-	{ NULL, NULL, LZMA_COMPRESSION, "lzma", 0 },
+extern struct compressor lzo_comp_ops;
 #endif
-#ifdef LZO_SUPPORT
-	{ lzo_compress, lzo_uncompress, LZO_COMPRESSION, "lzo", 1 },
+
+#ifndef XZ_SUPPORT
+static struct compressor xz_comp_ops = {
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, XZ_COMPRESSION, "xz", 0
+};
 #else
-	{ NULL, NULL, LZO_COMPRESSION, "lzo", 0 },
+extern struct compressor xz_comp_ops;
 #endif
 
-	{ NULL, NULL , 0, "unknown", 0}
+
+static struct compressor unknown_comp_ops = {
+	NULL, NULL, NULL , NULL, NULL, NULL, NULL, NULL, 0, "unknown", 0
+};
+
+
+struct compressor *compressor[] = {
+	&gzip_comp_ops,
+	&lzma_comp_ops,
+	&lzo_comp_ops,
+	&xz_comp_ops,
+	&unknown_comp_ops
 };
 
 
@@ -57,11 +78,11 @@
 {
 	int i;
 
-	for(i = 0; compressor[i].id; i++)
-		if(strcmp(compressor[i].name, name) == 0)
+	for(i = 0; compressor[i]->id; i++)
+		if(strcmp(compressor[i]->name, name) == 0)
 			break;
 
-	return &compressor[i];
+	return compressor[i];
 }
 
 
@@ -69,11 +90,11 @@
 {
 	int i;
 
-	for(i = 0; compressor[i].id; i++)
-		if(id == compressor[i].id)
+	for(i = 0; compressor[i]->id; i++)
+		if(id == compressor[i]->id)
 			break;
 
-	return &compressor[i];
+	return compressor[i];
 }
 
 
@@ -81,10 +102,29 @@
 {
 	int i;
 
-	for(i = 0; compressor[i].id; i++)
-		if(compressor[i].supported)
+	for(i = 0; compressor[i]->id; i++)
+		if(compressor[i]->supported)
 			fprintf(stderr, "%s\t%s%s\n", indent,
-				compressor[i].name,
-				strcmp(compressor[i].name, def_comp) == 0 ?
+				compressor[i]->name,
+				strcmp(compressor[i]->name, def_comp) == 0 ?
 				" (default)" : "");
 }
+
+
+void display_compressor_usage(char *def_comp)
+{
+	int i;
+
+	for(i = 0; compressor[i]->id; i++)
+		if(compressor[i]->supported) {
+			char *str = strcmp(compressor[i]->name, def_comp) == 0 ?
+				" (default)" : "";
+			if(compressor[i]->usage) {
+				fprintf(stderr, "\t%s%s\n",
+					compressor[i]->name, str);
+				compressor[i]->usage();
+			} else
+				fprintf(stderr, "\t%s (no options)%s\n",
+					compressor[i]->name, str);
+		}
+}
diff -aurN squashfs4.1.old/squashfs-tools/compressor.h squashfs4.1.new/squashfs-tools/compressor.h
--- squashfs4.1.old/squashfs-tools/compressor.h	2010-08-25 18:08:48.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/compressor.h	2010-12-31 07:57:25.000000000 +0000
@@ -21,8 +21,14 @@
  */
 
 struct compressor {
-	int (*compress)(void **, char *, char *, int, int, int *);
-	int (*uncompress)(char *, char *, int, int, int *);
+	int (*init)(void **, int, int);
+	int (*compress)(void *, void *, void *, int, int, int *);
+	int (*uncompress)(void *, void *, int, int, int *);
+	int (*options)(char **, int);
+	int (*options_post)(int);
+	void *(*dump_options)(int *);
+	int (*extract_options)(int, void *, int);
+	void (*usage)();
 	int id;
 	char *name;
 	int supported;
@@ -31,3 +37,61 @@
 extern struct compressor *lookup_compressor(char *);
 extern struct compressor *lookup_compressor_id(int);
 extern void display_compressors(char *, char *);
+extern void display_compressor_usage(char *);
+
+static inline int compressor_init(struct compressor *comp, void **stream,
+	int block_size, int datablock)
+{
+	if(comp->init == NULL)
+		return 0;
+	return comp->init(stream, block_size, datablock);
+}
+
+
+static inline int compressor_compress(struct compressor *comp, void *strm,
+	void *dest, void *src, int size, int block_size, int *error)
+{
+	return comp->compress(strm, dest, src, size, block_size, error);
+}
+
+
+static inline int compressor_uncompress(struct compressor *comp, void *dest,
+	void *src, int size, int block_size, int *error)
+{
+	return comp->uncompress(dest, src, size, block_size, error);
+}
+
+
+static inline int compressor_options(struct compressor *comp, char *argv[],
+	int argc)
+{
+	if(comp->options == NULL)
+		return -1;
+
+	return comp->options(argv, argc);
+}
+
+
+static inline int compressor_options_post(struct compressor *comp, int block_size)
+{
+	if(comp->options_post == NULL)
+		return 0;
+	return comp->options_post(block_size);
+}
+
+
+static inline void *compressor_dump_options(struct compressor *comp, int *size)
+{
+	if(comp->dump_options == NULL)
+		return NULL;
+	return comp->dump_options(size);
+}
+
+
+static inline int compressor_extract_options(struct compressor *comp,
+	int block_size, void *buffer, int size)
+{
+	if(comp->extract_options == NULL)
+		return size ? -1 : 0;
+	return comp->extract_options(block_size, buffer, size);
+}
diff -aurN squashfs4.1.old/squashfs-tools/global.h squashfs4.1.new/squashfs-tools/global.h
--- squashfs4.1.old/squashfs-tools/global.h	2010-07-21 03:06:51.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/global.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,49 +0,0 @@
-#ifndef GLOBAL_H 
-#define GLOBAL_H
-
-/*
- * Squashfs
- *
- * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
- * Phillip Lougher <phillip@lougher.demon.co.uk>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2,
- * or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- * global.h
- */
-
-typedef struct squashfs_super_block squashfs_super_block;
-typedef struct squashfs_dir_index squashfs_dir_index;
-typedef struct squashfs_base_inode_header squashfs_base_inode_header;
-typedef struct squashfs_ipc_inode_header squashfs_ipc_inode_header;
-typedef struct squashfs_lipc_inode_header squashfs_lipc_inode_header;
-typedef struct squashfs_dev_inode_header squashfs_dev_inode_header;
-typedef struct squashfs_ldev_inode_header squashfs_ldev_inode_header;
-typedef struct squashfs_symlink_inode_header squashfs_symlink_inode_header;
-typedef struct squashfs_reg_inode_header squashfs_reg_inode_header;
-typedef struct squashfs_lreg_inode_header squashfs_lreg_inode_header;
-typedef struct squashfs_dir_inode_header squashfs_dir_inode_header;
-typedef struct squashfs_ldir_inode_header squashfs_ldir_inode_header;
-typedef struct squashfs_dir_entry squashfs_dir_entry;
-typedef struct squashfs_dir_header squashfs_dir_header;
-typedef struct squashfs_fragment_entry squashfs_fragment_entry;
-typedef union squashfs_inode_header squashfs_inode_header;
-
-typedef unsigned int squashfs_id;
-typedef long long squashfs_fragment_index;
-typedef squashfs_inode_t squashfs_inode;
-typedef squashfs_block_t squashfs_block;
-
-#endif
diff -aurN squashfs4.1.old/squashfs-tools/gzip_wrapper.c squashfs4.1.new/squashfs-tools/gzip_wrapper.c
--- squashfs4.1.old/squashfs-tools/gzip_wrapper.c	2010-08-25 18:09:21.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/gzip_wrapper.c	2010-12-08 02:55:52.000000000 +0000
@@ -22,28 +22,48 @@
 #include <stdlib.h>
 #include <zlib.h>
 
-int gzip_compress(void **strm, char *d, char *s, int size, int block_size,
+#include "squashfs_fs.h"
+#include "compressor.h"
+
+static int gzip_init(void **strm, int block_size, int flags)
+{
+	int res;
+	z_stream *stream;
+
+	stream = *strm = malloc(sizeof(z_stream));
+	if(stream == NULL)
+		goto failed;
+
+	stream->zalloc = Z_NULL;
+	stream->zfree = Z_NULL;
+	stream->opaque = 0;
+
+	res = deflateInit(stream, 9);
+	if(res != Z_OK)
+		goto failed2;
+
+	return 0;
+
+failed2:
+	free(stream);
+failed:
+	return -1;
+}
+
+
+static int gzip_compress(void *strm, void *d, void *s, int size, int block_size,
 		int *error)
 {
-	int res = 0;
-	z_stream *stream = *strm;
+	int res;
+	z_stream *stream = strm;
 
-	if(stream == NULL) {
-		if((stream = *strm = malloc(sizeof(z_stream))) == NULL)
-			goto failed;
-
-		stream->zalloc = Z_NULL;
-		stream->zfree = Z_NULL;
-		stream->opaque = 0;
-
-		if((res = deflateInit(stream, 9)) != Z_OK)
-			goto failed;
-	} else if((res = deflateReset(stream)) != Z_OK)
+	res = deflateReset(stream);
+	if(res != Z_OK)
 		goto failed;
 
-	stream->next_in = (unsigned char *) s;
+	stream->next_in = s;
 	stream->avail_in = size;
-	stream->next_out = (unsigned char *) d;
+	stream->next_out = d;
 	stream->avail_out = block_size;
 
 	res = deflate(stream, Z_FINISH);
@@ -67,14 +87,26 @@
 }
 
 
-int gzip_uncompress(char *d, char *s, int size, int block_size, int *error)
+static int gzip_uncompress(void *d, void *s, int size, int block_size, int *error)
 {
 	int res;
 	unsigned long bytes = block_size;
 
-	res = uncompress((unsigned char *) d, &bytes,
-		(const unsigned char *) s, size);
+	res = uncompress(d, &bytes, s, size);
 
 	*error = res;
 	return res == Z_OK ? (int) bytes : -1;
 }
+
+
+struct compressor gzip_comp_ops = {
+	.init = gzip_init,
+	.compress = gzip_compress,
+	.uncompress = gzip_uncompress,
+	.options = NULL,
+	.usage = NULL,
+	.id = ZLIB_COMPRESSION,
+	.name = "gzip",
+	.supported = 1
+};
+
diff -aurN squashfs4.1.old/squashfs-tools/lzma_wrapper.c squashfs4.1.new/squashfs-tools/lzma_wrapper.c
--- squashfs4.1.old/squashfs-tools/lzma_wrapper.c	2010-08-25 18:09:35.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/lzma_wrapper.c	2010-12-08 02:56:51.000000000 +0000
@@ -17,21 +17,27 @@
  * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  *
  * lzma_wrapper.c
+ *
+ * Support for LZMA1 compression using LZMA SDK (4.65 used in
+ * development, other versions may work) http://www.7-zip.org/sdk.html
  */
 
 #include <LzmaLib.h>
 
+#include "squashfs_fs.h"
+#include "compressor.h"
+
 #define LZMA_HEADER_SIZE	(LZMA_PROPS_SIZE + 8)
 
-int lzma_compress(void **strm, char *dest, char *src, int size, int block_size,
+static int lzma_compress(void *strm, void *dest, void *src, int size, int block_size,
 		int *error)
 {
-	unsigned char *d = (unsigned char *) dest, *s = (unsigned char *) src;
+	unsigned char *d = dest;
 	size_t props_size = LZMA_PROPS_SIZE,
 		outlen = block_size - LZMA_HEADER_SIZE;
 	int res;
 
-	res = LzmaCompress(d + LZMA_HEADER_SIZE, &outlen, s, size, d,
+	res = LzmaCompress(dest + LZMA_HEADER_SIZE, &outlen, src, size, dest,
 		&props_size, 5, block_size, 3, 0, 2, 32, 1);
 	
 	if(res == SZ_ERROR_OUTPUT_EOF) {
@@ -73,10 +79,10 @@
 }
 
 
-int lzma_uncompress(char *dest, char *src, int size, int block_size,
+static int lzma_uncompress(void *dest, void *src, int size, int block_size,
 	int *error)
 {
-	unsigned char *d = (unsigned char *) dest, *s = (unsigned char *) src;
+	unsigned char *s = src;
 	size_t outlen, inlen = size - LZMA_HEADER_SIZE;
 	int res;
 
@@ -85,9 +91,22 @@
 		(s[LZMA_PROPS_SIZE + 2] << 16) |
 		(s[LZMA_PROPS_SIZE + 3] << 24);
 
-	res = LzmaUncompress(d, &outlen, s + LZMA_HEADER_SIZE, &inlen,
-		s, LZMA_PROPS_SIZE);
+	res = LzmaUncompress(dest, &outlen, src + LZMA_HEADER_SIZE, &inlen, src,
+		LZMA_PROPS_SIZE);
 	
 	*error = res;
 	return res == SZ_OK ? outlen : -1;
 }
+
+
+struct compressor lzma_comp_ops = {
+	.init = NULL,
+	.compress = lzma_compress,
+	.uncompress = lzma_uncompress,
+	.options = NULL,
+	.usage = NULL,
+	.id = LZMA_COMPRESSION,
+	.name = "lzma",
+	.supported = 1
+};
+
diff -aurN squashfs4.1.old/squashfs-tools/lzma_xz_wrapper.c squashfs4.1.new/squashfs-tools/lzma_xz_wrapper.c
--- squashfs4.1.old/squashfs-tools/lzma_xz_wrapper.c	1970-01-01 00:00:00.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/lzma_xz_wrapper.c	2010-12-16 04:41:26.000000000 +0000
@@ -0,0 +1,157 @@
+/*
+ * Copyright (c) 2010
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * lzma_xz_wrapper.c
+ *
+ * Support for LZMA1 compression using XZ Utils liblzma http://tukaani.org/xz/
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <lzma.h>
+
+#include "squashfs_fs.h"
+#include "compressor.h"
+
+#define LZMA_PROPS_SIZE 5
+#define LZMA_UNCOMP_SIZE 8
+#define LZMA_HEADER_SIZE (LZMA_PROPS_SIZE + LZMA_UNCOMP_SIZE)
+
+#define LZMA_OPTIONS 5
+#define MEMLIMIT (32 * 1024 * 1024)
+
+static int lzma_compress(void *dummy, void *dest, void *src,  int size,
+	int block_size, int *error)
+{
+	unsigned char *d = (unsigned char *) dest;
+	lzma_options_lzma opt;
+	lzma_stream strm = LZMA_STREAM_INIT;
+	int res;
+
+	lzma_lzma_preset(&opt, LZMA_OPTIONS);
+	opt.dict_size = block_size;
+
+	res = lzma_alone_encoder(&strm, &opt);
+	if(res != LZMA_OK) {
+		lzma_end(&strm);
+		goto failed;
+	}
+
+	strm.next_out = dest;
+	strm.avail_out = block_size;
+	strm.next_in = src;
+	strm.avail_in = size;
+
+	res = lzma_code(&strm, LZMA_FINISH);
+	lzma_end(&strm);
+
+	if(res == LZMA_STREAM_END) {
+		/*
+	 	 * Fill in the 8 byte little endian uncompressed size field in
+		 * the LZMA header.  8 bytes is excessively large for squashfs
+		 * but this is the standard LZMA header and which is expected by
+		 * the kernel code
+	 	 */
+
+		d[LZMA_PROPS_SIZE] = size & 255;
+		d[LZMA_PROPS_SIZE + 1] = (size >> 8) & 255;
+		d[LZMA_PROPS_SIZE + 2] = (size >> 16) & 255;
+		d[LZMA_PROPS_SIZE + 3] = (size >> 24) & 255;
+		d[LZMA_PROPS_SIZE + 4] = 0;
+		d[LZMA_PROPS_SIZE + 5] = 0;
+		d[LZMA_PROPS_SIZE + 6] = 0;
+		d[LZMA_PROPS_SIZE + 7] = 0;
+
+		return (int) strm.total_out;
+	}
+
+	if(res == LZMA_OK)
+		/*
+	 	 * Output buffer overflow.  Return out of buffer space
+	 	 */
+		return 0;
+
+failed:
+	/*
+	 * All other errors return failure, with the compressor
+	 * specific error code in *error
+	 */
+	*error = res;
+	return -1;
+}
+
+
+static int lzma_uncompress(void *dest, void *src, int size, int block_size,
+	int *error)
+{
+	lzma_stream strm = LZMA_STREAM_INIT;
+	int uncompressed_size = 0, res;
+	unsigned char lzma_header[LZMA_HEADER_SIZE];
+
+	res = lzma_alone_decoder(&strm, MEMLIMIT);
+	if(res != LZMA_OK) {
+		lzma_end(&strm);
+		goto failed;
+	}
+
+	memcpy(lzma_header, src, LZMA_HEADER_SIZE);
+	uncompressed_size = lzma_header[LZMA_PROPS_SIZE] |
+		(lzma_header[LZMA_PROPS_SIZE + 1] << 8) |
+		(lzma_header[LZMA_PROPS_SIZE + 2] << 16) |
+		(lzma_header[LZMA_PROPS_SIZE + 3] << 24);
+	memset(lzma_header + LZMA_PROPS_SIZE, 255, LZMA_UNCOMP_SIZE);
+
+	strm.next_out = dest;
+	strm.avail_out = block_size;
+	strm.next_in = lzma_header;
+	strm.avail_in = LZMA_HEADER_SIZE;
+
+	res = lzma_code(&strm, LZMA_RUN);
+
+	if(res != LZMA_OK || strm.avail_in != 0) {
+		lzma_end(&strm);
+		goto failed;
+	}
+
+	strm.next_in = src + LZMA_HEADER_SIZE;
+	strm.avail_in = size - LZMA_HEADER_SIZE;
+
+	res = lzma_code(&strm, LZMA_FINISH);
+	lzma_end(&strm);
+
+	if(res == LZMA_STREAM_END || (res == LZMA_OK &&
+		strm.total_out >= uncompressed_size && strm.avail_in == 0))
+		return uncompressed_size;
+
+failed:
+	*error = res;
+	return -1;
+}
+
+
+struct compressor lzma_comp_ops = {
+	.init = NULL,
+	.compress = lzma_compress,
+	.uncompress = lzma_uncompress,
+	.options = NULL,
+	.usage = NULL,
+	.id = LZMA_COMPRESSION,
+	.name = "lzma",
+	.supported = 1
+};
+
diff -aurN squashfs4.1.old/squashfs-tools/lzo_wrapper.c squashfs4.1.new/squashfs-tools/lzo_wrapper.c
--- squashfs4.1.old/squashfs-tools/lzo_wrapper.c	2010-09-14 02:00:57.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/lzo_wrapper.c	2010-12-08 02:56:16.000000000 +0000
@@ -2,6 +2,9 @@
  * Copyright (c) 2010 LG Electronics
  * Chan Jeong <chan.jeong@lge.com>
  *
+ * All modifications Copyright (c) 2010
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2,
@@ -25,6 +28,9 @@
 #include <lzo/lzoconf.h>
 #include <lzo/lzo1x.h>
 
+#include "squashfs_fs.h"
+#include "compressor.h"
+
 /* worst-case expansion calculation during compression,
    see LZO FAQ for more information */
 #define LZO_OUTPUT_BUFFER_SIZE(size)	(size + (size/16) + 64 + 3)
@@ -34,25 +40,39 @@
 	lzo_bytep out;
 };
 
-int lzo_compress(void **strm, char *d, char *s, int size, int block_size,
+
+static int squashfs_lzo_init(void **strm, int block_size, int flags)
+{
+	struct lzo_stream *stream;
+
+	if((stream = *strm = malloc(sizeof(struct lzo_stream))) == NULL)
+		goto failed;
+	/* work memory for compression */
+	if((stream->wrkmem = malloc(LZO1X_999_MEM_COMPRESS)) == NULL)
+		goto failed2;
+	/* temporal output buffer */
+	if((stream->out = malloc(LZO_OUTPUT_BUFFER_SIZE(block_size))) == NULL)
+		goto failed3;
+
+	return 0;
+
+failed3:
+	free(stream->wrkmem);
+failed2:
+	free(stream);
+failed:
+	return -1;
+}
+
+
+static int lzo_compress(void *strm, void *d, void *s, int size, int block_size,
 		int *error)
 {
-	int res = 0;
+	int res;
 	lzo_uint outlen;
-	struct lzo_stream *stream = *strm;
-
-	if(stream == NULL) {
-		if((stream = *strm = malloc(sizeof(struct lzo_stream))) == NULL)
-			goto failed;
-		/* work memory for compression */
-		if((stream->wrkmem = malloc(LZO1X_999_MEM_COMPRESS)) == NULL)
-			goto failed;
-		/* temporal output buffer */
-		if((stream->out = malloc(LZO_OUTPUT_BUFFER_SIZE(block_size))) == NULL)
-			goto failed;
-	}
+	struct lzo_stream *stream = strm;
 
-	res = lzo1x_999_compress((lzo_bytep)s, size, stream->out, &outlen, stream->wrkmem);
+	res = lzo1x_999_compress(s, size, stream->out, &outlen, stream->wrkmem);
 	if(res != LZO_E_OK)
 		goto failed;
 	if(outlen >= size)
@@ -77,13 +97,26 @@
 }
 
 
-int lzo_uncompress(char *d, char *s, int size, int block_size, int *error)
+static int lzo_uncompress(void *d, void *s, int size, int block_size, int *error)
 {
 	int res;
 	lzo_uint bytes = block_size;
 
-	res = lzo1x_decompress_safe((lzo_bytep)s, size, (lzo_bytep)d, &bytes, NULL);
+	res = lzo1x_decompress_safe(s, size, d, &bytes, NULL);
 
 	*error = res;
 	return res == LZO_E_OK ? bytes : -1;
 }
+
+
+struct compressor lzo_comp_ops = {
+	.init = squashfs_lzo_init,
+	.compress = lzo_compress,
+	.uncompress = lzo_uncompress,
+	.options = NULL,
+	.usage = NULL,
+	.id = LZO_COMPRESSION,
+	.name = "lzo",
+	.supported = 1
+};
+
diff -aurN squashfs4.1.old/squashfs-tools/Makefile squashfs4.1.new/squashfs-tools/Makefile
--- squashfs4.1.old/squashfs-tools/Makefile	2010-09-20 22:11:47.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/Makefile	2010-12-31 21:36:47.000000000 +0000
@@ -20,19 +20,32 @@
 
 ########### Building LZMA support #############
 #
-# Both XZ Utils liblzma  (http://tukaani.org/xz/) and LZMA SDK
+# LZMA1 compression.
+#
+# Both XZ Utils liblzma (http://tukaani.org/xz/) and LZMA SDK
 # (http://www.7-zip.org/sdk.html) are supported
 #
 # To build using XZ Utils liblzma - install the library and uncomment
-# the XZ_SUPPORT line below.
+# the LZMA_XZ_SUPPORT line below.
 #
 # To build using the LZMA SDK (4.65 used in development, other versions may
 # work) - download and unpack it, uncomment and set LZMA_DIR to unpacked source,
 # and uncomment the LZMA_SUPPORT line below.
 #
-#XZ_SUPPORT = 1
+#LZMA_XZ_SUPPORT = 1
 #LZMA_SUPPORT = 1
-#LZMA_DIR = ../../../LZMA/lzma465
+#LZMA_DIR = ../../../../LZMA/lzma465
+
+########### Building XZ support #############
+#
+# LZMA2 compression.
+#
+# XZ Utils liblzma (http://tukaani.org/xz/) is supported
+#
+# To build using XZ Utils liblzma - install the library and uncomment
+# the XZ_SUPPORT line below.
+#
+#XZ_SUPPORT = 1
 
 
 ############ Building LZO support ##############
@@ -90,7 +103,7 @@
 CFLAGS = $(INCLUDEDIR) -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE \
 	-D_GNU_SOURCE -DCOMP_DEFAULT=\"$(COMP_DEFAULT)\"  -O2 -Wall
 
-LIBS =
+LIBS = -lpthread -lm
 ifdef GZIP_SUPPORT
 CFLAGS += -DGZIP_SUPPORT
 MKSQUASHFS_OBJS += gzip_wrapper.o
@@ -109,12 +122,20 @@
 COMPRESSORS += lzma
 endif
 
-ifdef XZ_SUPPORT
+ifdef LZMA_XZ_SUPPORT
 CFLAGS += -DLZMA_SUPPORT
+MKSQUASHFS_OBJS += lzma_xz_wrapper.o
+UNSQUASHFS_OBJS += lzma_xz_wrapper.o
+LIBS += -llzma
+COMPRESSORS += lzma
+endif
+
+ifdef XZ_SUPPORT
+CFLAGS += -DXZ_SUPPORT
 MKSQUASHFS_OBJS += xz_wrapper.o
 UNSQUASHFS_OBJS += xz_wrapper.o
 LIBS += -llzma
-COMPRESSORS += lzma
+COMPRESSORS += xz
 endif
 
 ifdef LZO_SUPPORT
@@ -140,7 +161,7 @@
 endif
 
 #
-# If LZMA_SUPPORT is specified then LZO_DIR must be specified too
+# If LZMA_SUPPORT is specified then LZMA_DIR must be specified too
 #
 ifdef LZMA_SUPPORT
 ifndef LZMA_DIR
@@ -149,11 +170,11 @@
 endif
 
 #
-# Both XZ_SUPPORT and LZMA_SUPPORT cannot be specified
+# Both LZMA_XZ_SUPPORT and LZMA_SUPPORT cannot be specified
 #
-ifdef XZ_SUPPORT
+ifdef LZMA_XZ_SUPPORT
 ifdef LZMA_SUPPORT
-$(error "Both XZ_SUPPORT and LZMA_SUPPORT cannot be specified")
+$(error "Both LZMA_XZ_SUPPORT and LZMA_SUPPORT cannot be specified")
 endif
 endif
 
@@ -161,7 +182,7 @@
 # At least one compressor must have been selected
 #
 ifndef COMPRESSORS
-$(error "No compressor selected! Select one or more of GZIP, LZMA, or LZO!")
+$(error "No compressor selected! Select one or more of GZIP, LZMA, XZ or LZO!")
 endif
 
 #
@@ -175,44 +196,53 @@
 all: mksquashfs unsquashfs
 
 mksquashfs: $(MKSQUASHFS_OBJS)
-	$(CC) $(MKSQUASHFS_OBJS) -lpthread -lm $(LIBS) -o $@
+	$(CC) $(MKSQUASHFS_OBJS) $(LIBS) -o $@
 
-mksquashfs.o: mksquashfs.c squashfs_fs.h mksquashfs.h global.h sort.h \
-	squashfs_swap.h xattr.h
+mksquashfs.o: mksquashfs.c squashfs_fs.h mksquashfs.h sort.h squashfs_swap.h \
+	xattr.h pseudo.h compressor.h
 
-read_fs.o: read_fs.c squashfs_fs.h read_fs.h global.h squashfs_swap.h
+read_fs.o: read_fs.c squashfs_fs.h read_fs.h squashfs_swap.h compressor.h \
+	xattr.h
 
-sort.o: sort.c squashfs_fs.h global.h sort.h
+sort.o: sort.c squashfs_fs.h sort.h mksquashfs.h
 
 swap.o: swap.c
 
 pseudo.o: pseudo.c pseudo.h
 
-compressor.o: compressor.c compressor.h
+compressor.o: compressor.c compressor.h squashfs_fs.h
 
-xattr.o: xattr.h
+xattr.o: xattr.c xattr.h squashfs_fs.h squashfs_swap.h mksquashfs.h
 
-read_xattrs.o: xattr.h
+read_xattrs.o: read_xattrs.c xattr.h squashfs_fs.h squashfs_swap.h read_fs.h
+
+gzip_wrapper.o: gzip_wrapper.c compressor.h squashfs_fs.h
+
+lzma_wrapper.o: lzma_wrapper.c compressor.h squashfs_fs.h
+
+lzma_xz_wrapper.o: lzma_xz_wrapper.c compressor.h squashfs_fs.h
+
+lzo_wrapper.o: lzo_wrapper.c compressor.h squashfs_fs.h
+
+xz_wrapper.o: xz_wrapper.c compressor.h squashfs_fs.h
 
 unsquashfs: $(UNSQUASHFS_OBJS)
-	$(CC) $(UNSQUASHFS_OBJS) -lpthread -lm $(LIBS) -o $@
+	$(CC) $(UNSQUASHFS_OBJS) $(LIBS) -o $@
 
 unsquashfs.o: unsquashfs.h unsquashfs.c squashfs_fs.h squashfs_swap.h \
-	squashfs_compat.h global.h xattr.h
+	squashfs_compat.h xattr.h read_fs.h compressor.h
 
-unsquash-1.o: unsquashfs.h unsquash-1.c squashfs_fs.h squashfs_compat.h \
-	global.h
+unsquash-1.o: unsquashfs.h unsquash-1.c squashfs_fs.h squashfs_compat.h
 
-unsquash-2.o: unsquashfs.h unsquash-2.c unsquashfs.h squashfs_fs.h \
-	squashfs_compat.h global.h
+unsquash-2.o: unsquashfs.h unsquash-2.c squashfs_fs.h squashfs_compat.h
 
-unsquash-3.o: unsquashfs.h unsquash-3.c squashfs_fs.h squashfs_compat.h \
-	global.h
+unsquash-3.o: unsquashfs.h unsquash-3.c squashfs_fs.h squashfs_compat.h
 
 unsquash-4.o: unsquashfs.h unsquash-4.c squashfs_fs.h squashfs_swap.h \
-	global.h
+	read_fs.h
+
+unsquashfs_xattr.o: unsquashfs_xattr.c unsquashfs.h squashfs_fs.h xattr.h
 
-unsquashfs_xattr.o: xattr.h
 
 .PHONY: clean
 clean:
diff -aurN squashfs4.1.old/squashfs-tools/mksquashfs.c squashfs4.1.new/squashfs-tools/mksquashfs.c
--- squashfs4.1.old/squashfs-tools/mksquashfs.c	2010-09-19 21:44:11.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/mksquashfs.c	2010-12-31 21:41:21.000000000 +0000
@@ -106,7 +106,6 @@
 		} while(0)
 
 #include "squashfs_fs.h"
-#include "global.h"
 #include "squashfs_swap.h"
 #include "mksquashfs.h"
 #include "sort.h"
@@ -114,15 +113,13 @@
 #include "compressor.h"
 #include "xattr.h"
 
-/* offset of data in compressed metadata blocks (allowing room for
- * compressed size */
-#define BLOCK_OFFSET 2
 int delete = FALSE;
 int fd;
 int cur_uncompressed = 0, estimated_uncompressed = 0;
 int columns;
 
 /* filesystem flags for building */
+int comp_opts = FALSE;
 int no_xattrs = XATTR_DEF, noX = 0;
 int duplicate_checking = 1, noF = 0, no_fragments = 0, always_use_fragments = 0;
 int noI = 0, noD = 0;
@@ -172,8 +169,8 @@
 #define INODE_HASH(dev, ino)	(ino & INODE_HASH_MASK)
 
 struct cached_dir_index {
-	squashfs_dir_index	index;
-	char			*name;
+	struct squashfs_dir_index	index;
+	char				*name;
 };
 
 struct directory {
@@ -244,7 +241,7 @@
 #define FRAG_SIZE 32768
 #define FRAG_INDEX (1LL << 32)
 
-squashfs_fragment_entry *fragment_table = NULL;
+struct squashfs_fragment_entry *fragment_table = NULL;
 int fragments_outstanding = 0;
 
 /* current inode number for directories and non directories */
@@ -384,9 +381,10 @@
 #define FRAGMENT_BUFFER_DEFAULT 64
 int writer_buffer_size;
 
-/* compression operations structure */
+/* compression operations */
 static struct compressor *comp;
-char *comp_name = COMP_DEFAULT;
+int compressor_opts_parsed = 0;
+void *stream = NULL;
 
 /* xattr stats */
 unsigned int xattr_bytes = 0, total_xattr_bytes = 0;
@@ -394,10 +392,10 @@
 char *read_from_disk(long long start, unsigned int avail_bytes);
 void add_old_root_entry(char *name, squashfs_inode inode, int inode_number,
 	int type);
-extern struct compressor  *read_super(int fd, squashfs_super_block *sBlk,
+extern struct compressor  *read_super(int fd, struct squashfs_super_block *sBlk,
 	char *source);
 extern long long read_filesystem(char *root_name, int fd,
-	squashfs_super_block *sBlk, char **cinode_table, char **data_cache,
+	struct squashfs_super_block *sBlk, char **cinode_table, char **data_cache,
 	char **cdirectory_table, char **directory_data_cache,
 	unsigned int *last_directory_block, unsigned int *inode_dir_offset,
 	unsigned int *inode_dir_file_size, unsigned int *root_inode_size,
@@ -408,7 +406,7 @@
 	unsigned int *inode_dir_inode_number,
 	unsigned int *inode_dir_parent_inode,
 	void (push_directory_entry)(char *, squashfs_inode, int, int),
-	squashfs_fragment_entry **fragment_table,
+	struct squashfs_fragment_entry **fragment_table,
 	squashfs_inode **inode_lookup_table);
 extern int read_sort_file(char *filename, int source, char *source_path[]);
 extern void sort_files_and_write(struct dir_info *dir);
@@ -439,7 +437,8 @@
 	if(queue == NULL)
 		goto failed;
 
-	if((queue->data = malloc(sizeof(void *) * (size + 1))) == NULL) {
+	queue->data = malloc(sizeof(void *) * (size + 1));
+	if(queue->data == NULL) {
 		free(queue);
 		goto failed;
 	}
@@ -859,13 +858,14 @@
 }
 
 
-int mangle2(void **strm, char *d, char *s, int size,
+int mangle2(void *strm, char *d, char *s, int size,
 	int block_size, int uncompressed, int data_block)
 {
 	int error, c_byte = 0;
 
 	if(!uncompressed) {
-		c_byte = comp->compress(strm, d, s, size, block_size, &error);
+		c_byte = compressor_compress(comp, strm, d, s, size, block_size,
+			 &error);
 		if(c_byte == -1)
 			BAD_ERROR("mangle2:: %s compress failed with error "
 				"code %d\n", comp->name, error);
@@ -884,9 +884,7 @@
 int mangle(char *d, char *s, int size, int block_size,
 	int uncompressed, int data_block)
 {
-	static void *stream = NULL;
-
-	return mangle2(&stream, d, s, size, block_size, uncompressed,
+	return mangle2(stream, d, s, size, block_size, uncompressed,
 		data_block);
 }
 
@@ -1016,7 +1014,7 @@
 }
 
 
-void write_destination(int fd, long long byte, int bytes, char *buff)
+void write_destination(int fd, long long byte, int bytes, void *buff)
 {
 	off_t off = byte;
 
@@ -1066,7 +1064,7 @@
 		cache_bytes -= avail_bytes;
 	}
 
-	write_destination(fd, bytes, inode_bytes, (char *) inode_table);
+	write_destination(fd, bytes, inode_bytes,  inode_table);
 	bytes += inode_bytes;
 
 	return start_bytes;
@@ -1108,7 +1106,7 @@
 		directoryp += avail_bytes;
 		directory_cache_bytes -= avail_bytes;
 	}
-	write_destination(fd, bytes, directory_bytes, (char *) directory_table);
+	write_destination(fd, bytes, directory_bytes, directory_table);
 	bytes += directory_bytes;
 
 	return start_bytes;
@@ -1204,8 +1202,8 @@
 	struct fragment *fragment, struct directory *dir_in, long long sparse)
 {
 	struct stat *buf = &dir_ent->inode->buf;
-	squashfs_inode_header inode_header;
-	squashfs_base_inode_header *base = &inode_header.base;
+	union squashfs_inode_header inode_header;
+	struct squashfs_base_inode_header *base = &inode_header.base;
 	void *inode;
 	char *filename = dir_ent->pathname;
 	int nlink = dir_ent->inode->nlink;
@@ -1259,8 +1257,8 @@
 
 	if(type == SQUASHFS_FILE_TYPE) {
 		int i;
-		squashfs_reg_inode_header *reg = &inode_header.reg;
-		size_t off = offsetof(squashfs_reg_inode_header, block_list);
+		struct squashfs_reg_inode_header *reg = &inode_header.reg;
+		size_t off = offsetof(struct squashfs_reg_inode_header, block_list);
 
 		inode = get_inode(sizeof(*reg) + offset * sizeof(unsigned int));
 		reg->file_size = byte_size;
@@ -1278,8 +1276,8 @@
 	}
 	else if(type == SQUASHFS_LREG_TYPE) {
 		int i;
-		squashfs_lreg_inode_header *reg = &inode_header.lreg;
-		size_t off = offsetof(squashfs_lreg_inode_header, block_list);
+		struct squashfs_lreg_inode_header *reg = &inode_header.lreg;
+		size_t off = offsetof(struct squashfs_lreg_inode_header, block_list);
 
 		inode = get_inode(sizeof(*reg) + offset * sizeof(unsigned int));
 		reg->nlink = nlink;
@@ -1303,7 +1301,7 @@
 	else if(type == SQUASHFS_LDIR_TYPE) {
 		int i;
 		unsigned char *p;
-		squashfs_ldir_inode_header *dir = &inode_header.ldir;
+		struct squashfs_ldir_inode_header *dir = &inode_header.ldir;
 		struct cached_dir_index *index = dir_in->index;
 		unsigned int i_count = dir_in->i_count;
 		unsigned int i_size = dir_in->i_size;
@@ -1324,10 +1322,10 @@
 		dir->xattr = xattr;
 
 		SQUASHFS_SWAP_LDIR_INODE_HEADER(dir, inode);
-		p = inode + offsetof(squashfs_ldir_inode_header, index);
+		p = inode + offsetof(struct squashfs_ldir_inode_header, index);
 		for(i = 0; i < i_count; i++) {
 			SQUASHFS_SWAP_DIR_INDEX(&index[i].index, p);
-			p += offsetof(squashfs_dir_index, name);
+			p += offsetof(struct squashfs_dir_index, name);
 			memcpy(p, index[i].name, index[i].index.size + 1);
 			p += index[i].index.size + 1;
 		}
@@ -1336,7 +1334,7 @@
 			start_block, offset, dir_ent->dir->directory_count + 2);
 	}
 	else if(type == SQUASHFS_DIR_TYPE) {
-		squashfs_dir_inode_header *dir = &inode_header.dir;
+		struct squashfs_dir_inode_header *dir = &inode_header.dir;
 
 		inode = get_inode(sizeof(*dir));
 		dir->nlink = dir_ent->dir->directory_count + 2;
@@ -1352,7 +1350,7 @@
 			offset, dir_ent->dir->directory_count + 2);
 	}
 	else if(type == SQUASHFS_CHRDEV_TYPE || type == SQUASHFS_BLKDEV_TYPE) {
-		squashfs_dev_inode_header *dev = &inode_header.dev;
+		struct squashfs_dev_inode_header *dev = &inode_header.dev;
 		unsigned int major = major(buf->st_rdev);
 		unsigned int minor = minor(buf->st_rdev);
 
@@ -1376,7 +1374,7 @@
 		TRACE("Device inode, rdev 0x%x, nlink %d\n", dev->rdev, nlink);
 	}
 	else if(type == SQUASHFS_LCHRDEV_TYPE || type == SQUASHFS_LBLKDEV_TYPE) {
-		squashfs_ldev_inode_header *dev = &inode_header.ldev;
+		struct squashfs_ldev_inode_header *dev = &inode_header.ldev;
 		unsigned int major = major(buf->st_rdev);
 		unsigned int minor = minor(buf->st_rdev);
 
@@ -1401,12 +1399,13 @@
 		TRACE("Device inode, rdev 0x%x, nlink %d\n", dev->rdev, nlink);
 	}
 	else if(type == SQUASHFS_SYMLINK_TYPE) {
-		squashfs_symlink_inode_header *symlink = &inode_header.symlink;
+		struct squashfs_symlink_inode_header *symlink = &inode_header.symlink;
 		int byte;
 		char buff[65536];
-		size_t off = offsetof(squashfs_symlink_inode_header, symlink);
+		size_t off = offsetof(struct squashfs_symlink_inode_header, symlink);
 
-		if((byte = readlink(filename, buff, 65536)) == -1) {
+		byte = readlink(filename, buff, 65536);
+		if(byte == -1) {
 			ERROR("Failed to read symlink %s, creating empty "
 				"symlink\n", filename);
 			byte = 0;
@@ -1427,12 +1426,13 @@
 			nlink);
 	}
 	else if(type == SQUASHFS_LSYMLINK_TYPE) {
-		squashfs_symlink_inode_header *symlink = &inode_header.symlink;
+		struct squashfs_symlink_inode_header *symlink = &inode_header.symlink;
 		int byte;
 		char buff[65536];
-		size_t off = offsetof(squashfs_symlink_inode_header, symlink);
+		size_t off = offsetof(struct squashfs_symlink_inode_header, symlink);
 
-		if((byte = readlink(filename, buff, 65536)) == -1) {
+		byte = readlink(filename, buff, 65536);
+		if(byte == -1) {
 			ERROR("Failed to read symlink %s, creating empty "
 				"symlink\n", filename);
 			byte = 0;
@@ -1455,7 +1455,7 @@
 			nlink);
 	}
 	else if(type == SQUASHFS_FIFO_TYPE || type == SQUASHFS_SOCKET_TYPE) {
-		squashfs_ipc_inode_header *ipc = &inode_header.ipc;
+		struct squashfs_ipc_inode_header *ipc = &inode_header.ipc;
 
 		inode = get_inode(sizeof(*ipc));
 		ipc->nlink = nlink;
@@ -1464,7 +1464,7 @@
 			SQUASHFS_FIFO_TYPE ? "fifo" : "socket", nlink);
 	}
 	else if(type == SQUASHFS_LFIFO_TYPE || type == SQUASHFS_LSOCKET_TYPE) {
-		squashfs_lipc_inode_header *ipc = &inode_header.lipc;
+		struct squashfs_lipc_inode_header *ipc = &inode_header.lipc;
 
 		inode = get_inode(sizeof(*ipc));
 		ipc->nlink = nlink;
@@ -1487,7 +1487,8 @@
 
 void scan3_init_dir(struct directory *dir)
 {
-	if((dir->buff = malloc(SQUASHFS_METADATA_SIZE)) == NULL) {
+	dir->buff = malloc(SQUASHFS_METADATA_SIZE);
+	if(dir->buff == NULL) {
 		BAD_ERROR("Out of memory allocating directory buffer\n");
 	}
 
@@ -1504,20 +1505,21 @@
 	int type, struct directory *dir)
 {
 	unsigned char *buff;
-	squashfs_dir_entry idir;
+	struct squashfs_dir_entry idir;
 	unsigned int start_block = inode >> 16;
 	unsigned int offset = inode & 0xffff;
-	unsigned int size;
-	size_t name_off = offsetof(squashfs_dir_entry, name);
+	unsigned int size = strlen(name);
+	size_t name_off = offsetof(struct squashfs_dir_entry, name);
 
-	if((size = strlen(name)) > SQUASHFS_NAME_LEN) {
+	if(size > SQUASHFS_NAME_LEN) {
 		size = SQUASHFS_NAME_LEN;
 		ERROR("Filename is greater than %d characters, truncating! ..."
 			"\n", SQUASHFS_NAME_LEN);
 	}
 
-	if(dir->p + sizeof(squashfs_dir_entry) + size +
-			sizeof(squashfs_dir_header) >= dir->buff + dir->size) {
+	if(dir->p + sizeof(struct squashfs_dir_entry) + size +
+			sizeof(struct squashfs_dir_header)
+			>= dir->buff + dir->size) {
 		buff = realloc(dir->buff, dir->size += SQUASHFS_METADATA_SIZE);
 		if(buff == NULL)  {
 			BAD_ERROR("Out of memory reallocating directory buffer"
@@ -1534,15 +1536,15 @@
 
 	if(dir->entry_count == 256 || start_block != dir->start_block ||
 			((dir->entry_count_p != NULL) &&
-			((dir->p + sizeof(squashfs_dir_entry) + size -
+			((dir->p + sizeof(struct squashfs_dir_entry) + size -
 			dir->index_count_p) > SQUASHFS_METADATA_SIZE)) ||
 			((long long) inode_number - dir->inode_number) > 32767
 			|| ((long long) inode_number - dir->inode_number)
 			< -32768) {
 		if(dir->entry_count_p) {
-			squashfs_dir_header dir_header;
+			struct squashfs_dir_header dir_header;
 
-			if((dir->p + sizeof(squashfs_dir_entry) + size -
+			if((dir->p + sizeof(struct squashfs_dir_entry) + size -
 					dir->index_count_p) >
 					SQUASHFS_METADATA_SIZE) {
 				if(dir->i_count % I_COUNT_SIZE == 0) {
@@ -1558,8 +1560,8 @@
 					dir->p - dir->buff;
 				dir->index[dir->i_count].index.size = size - 1;
 				dir->index[dir->i_count++].name = name;
-				dir->i_size += sizeof(squashfs_dir_index) +
-					size;
+				dir->i_size += sizeof(struct squashfs_dir_index)
+					+ size;
 				dir->index_count_p = dir->p;
 			}
 
@@ -1576,7 +1578,7 @@
 		dir->start_block = start_block;
 		dir->entry_count = 0;
 		dir->inode_number = inode_number;
-		dir->p += sizeof(squashfs_dir_header);
+		dir->p += sizeof(struct squashfs_dir_header);
 	}
 
 	idir.offset = offset;
@@ -1585,7 +1587,7 @@
 	idir.inode_number = ((long long) inode_number - dir->inode_number);
 	SQUASHFS_SWAP_DIR_ENTRY(&idir, dir->p);
 	strncpy((char *) dir->p + name_off, name, size);
-	dir->p += sizeof(squashfs_dir_entry) + size;
+	dir->p += sizeof(struct squashfs_dir_entry) + size;
 	dir->entry_count ++;
 }
 
@@ -1594,7 +1596,7 @@
 	struct directory *dir)
 {
 	unsigned int dir_size = dir->p - dir->buff;
-	int data_space = (directory_cache_size - directory_cache_bytes);
+	int data_space = directory_cache_size - directory_cache_bytes;
 	unsigned int directory_block, directory_offset, i_count, index;
 	unsigned short c_byte;
 
@@ -1613,7 +1615,7 @@
 	}
 
 	if(dir_size) {
-		squashfs_dir_header dir_header;
+		struct squashfs_dir_header dir_header;
 
 		dir_header.count = dir->entry_count - 1;
 		dir_header.start_block = dir->start_block;
@@ -1680,24 +1682,25 @@
 		dirp = dir->buff;
 		while(dirp < dir->p) {
 			char buffer[SQUASHFS_NAME_LEN + 1];
-			squashfs_dir_entry idir, *idirp;
-			squashfs_dir_header dirh;
-			SQUASHFS_SWAP_DIR_HEADER((squashfs_dir_header *) dirp,
+			struct squashfs_dir_entry idir, *idirp;
+			struct squashfs_dir_header dirh;
+			SQUASHFS_SWAP_DIR_HEADER((struct squashfs_dir_header *) dirp,
 				&dirh);
 			count = dirh.count + 1;
-			dirp += sizeof(squashfs_dir_header);
+			dirp += sizeof(struct squashfs_dir_header);
 
 			TRACE("\tStart block 0x%x, count %d\n",
 				dirh.start_block, count);
 
 			while(count--) {
-				idirp = (squashfs_dir_entry *) dirp;
+				idirp = (struct squashfs_dir_entry *) dirp;
 				SQUASHFS_SWAP_DIR_ENTRY(idirp, &idir);
 				strncpy(buffer, idirp->name, idir.size + 1);
 				buffer[idir.size + 1] = '\0';
 				TRACE("\t\tname %s, inode offset 0x%x, type "
 					"%d\n", buffer, idir.offset, idir.type);
-				dirp += sizeof(squashfs_dir_entry) + idir.size +					 1;
+				dirp += sizeof(struct squashfs_dir_entry) + idir.size +
+					1;
 			}
 		}
 	}
@@ -1713,7 +1716,7 @@
 
 struct file_buffer *get_fragment(struct fragment *fragment)
 {
-	squashfs_fragment_entry *disk_fragment;
+	struct squashfs_fragment_entry *disk_fragment;
 	int res, size;
 	long long start_block;
 	struct file_buffer *buffer, *compressed_buffer;
@@ -1745,8 +1748,8 @@
 		else
 			data = read_from_disk(start_block, size);
 
-		res = comp->uncompress(buffer->data, data, size, block_size,
-			&error);
+		res = compressor_uncompress(comp, buffer->data, data, size,
+			block_size, &error);
 		if(res == -1)
 			BAD_ERROR("%s uncompress failed with error code %d\n",
 				comp->name, error);
@@ -1838,7 +1841,7 @@
 	pthread_mutex_lock(&fragment_mutex);
 	if(fragments % FRAG_SIZE == 0) {
 		void *ft = realloc(fragment_table, (fragments +
-			FRAG_SIZE) * sizeof(squashfs_fragment_entry));
+			FRAG_SIZE) * sizeof(struct squashfs_fragment_entry));
 		if(ft == NULL) {
 			pthread_mutex_unlock(&fragment_mutex);
 			BAD_ERROR("Out of memory in fragment table\n");
@@ -1868,7 +1871,8 @@
 	if(fragment_size + file_buffer->size > block_size)
 		write_fragment();
 
-	if((ffrg = malloc(sizeof(struct fragment))) == NULL)
+	ffrg = malloc(sizeof(struct fragment));
+	if(ffrg == NULL)
 		BAD_ERROR("Out of memory in fragment block allocation!\n");
 
 	if(fragment_size == 0)
@@ -1926,7 +1930,7 @@
 	}
 		
 	SQUASHFS_INSWAP_LONG_LONGS(list, meta_blocks);
-	write_destination(fd, bytes, sizeof(list), (char *) list);
+	write_destination(fd, bytes, sizeof(list), list);
 	bytes += sizeof(list);
 	total_bytes += sizeof(list);
 
@@ -1940,7 +1944,7 @@
 long long write_fragment_table()
 {
 	unsigned int frag_bytes = SQUASHFS_FRAGMENT_BYTES(fragments);
-	squashfs_fragment_entry p[fragments];
+	struct squashfs_fragment_entry p[fragments];
 	int i;
 
 	TRACE("write_fragment_table: fragments %d, frag_bytes %d\n", fragments,
@@ -2067,7 +2071,8 @@
 		return;
 	}
 
-	if((frg = malloc(sizeof(struct fragment))) == NULL)
+	frg = malloc(sizeof(struct fragment));
+	if(frg == NULL)
 		BAD_ERROR("Out of memory in fragment block allocation!\n");
 
 	frg->index = fragment;
@@ -2122,9 +2127,9 @@
 	unsigned short checksum, unsigned short fragment_checksum,
 	int checksum_flag)
 {
-	struct file_info *dupl_ptr;
+	struct file_info *dupl_ptr = malloc(sizeof(struct file_info));
 
-	if((dupl_ptr = malloc(sizeof(struct file_info))) == NULL) {
+	if(dupl_ptr == NULL) {
 		BAD_ERROR("Out of memory in dup_files allocation!\n");
 	}
 
@@ -2355,7 +2360,8 @@
 	frag_block = !no_fragments && (always_use_fragments ||
 		(read_size < block_size)) ? read_size >> block_log : -1;
 
-	if((file = open(dir_ent->pathname, O_RDONLY)) == -1) {
+	file = open(dir_ent->pathname, O_RDONLY);
+	if(file == -1) {
 		file_buffer = cache_get(reader_buffer, 0, 0);
 		file_buffer->sequence = seq ++;
 		goto read_err;
@@ -2506,7 +2512,7 @@
 
 		if(file_buffer == NULL) {
 			queue_put(from_writer,
-				write_error ? (void *) &write_error : NULL);
+				write_error ? &write_error : NULL);
 			continue;
 		}
 
@@ -2556,11 +2562,15 @@
 void *deflator(void *arg)
 {
 	void *stream = NULL;
-	int oldstate;
+	int res, oldstate;
 
 	pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &oldstate);
 	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &oldstate);
 
+	res = compressor_init(comp, &stream, block_size, 1);
+	if(res)
+		BAD_ERROR("deflator:: compressor_init failed\n");
+
 	while(1) {
 		struct file_buffer *file_buffer = queue_get(from_reader);
 		struct file_buffer *write_buffer;
@@ -2573,7 +2583,7 @@
 			queue_put(from_deflate, file_buffer);
 		} else {
 			write_buffer = cache_get(writer_buffer, 0, 0);
-			write_buffer->c_byte = mangle2(&stream,
+			write_buffer->c_byte = mangle2(stream,
 				write_buffer->data, file_buffer->data,
 				file_buffer->size, block_size, noD, 1);
 			write_buffer->sequence = file_buffer->sequence;
@@ -2593,11 +2603,15 @@
 void *frag_deflator(void *arg)
 {
 	void *stream = NULL;
-	int oldstate;
+	int res, oldstate;
 
 	pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &oldstate);
 	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &oldstate);
 
+	res = compressor_init(comp, &stream, block_size, 1);
+	if(res)
+		BAD_ERROR("frag_deflator:: compressor_init failed\n");
+
 	while(1) {
 		int c_byte, compressed_size;
 		struct file_buffer *file_buffer = queue_get(to_frag);
@@ -2605,7 +2619,7 @@
 			cache_get(writer_buffer, file_buffer->block +
 			FRAG_INDEX, 1);
 
-		c_byte = mangle2(&stream, write_buffer->data, file_buffer->data,
+		c_byte = mangle2(stream, write_buffer->data, file_buffer->data,
 			file_buffer->size, block_size, noF, 1);
 		compressed_size = SQUASHFS_COMPRESSED_SIZE_BLOCK(c_byte);
 		write_buffer->size = compressed_size;
@@ -2959,7 +2973,8 @@
 
 	*duplicate_file = FALSE;
 
-	if((block_list = malloc(blocks * sizeof(unsigned int))) == NULL)
+	block_list = malloc(blocks * sizeof(unsigned int));
+	if(block_list == NULL)
 		BAD_ERROR("Out of memory allocating block_list\n");
 
 	lock_fragments();
@@ -3297,7 +3312,8 @@
 		inode = inode->next;
 	}
 
-	if((inode = malloc(sizeof(struct inode_info))) == NULL)
+	inode = malloc(sizeof(struct inode_info));
+	if(inode == NULL)
 		BAD_ERROR("Out of memory in inode hash table entry allocation"
 			"\n");
 
@@ -3334,7 +3350,8 @@
 			BAD_ERROR("Out of memory in add_dir_entry\n");
 	}
 
-	if((dir->list[dir->count] = malloc(sizeof(struct dir_ent))) == NULL)
+	dir->list[dir->count] = malloc(sizeof(struct dir_ent));
+	if(dir->list[dir->count] == NULL)
 		BAD_ERROR("Out of memory in linux_opendir\n");
 
 	if(sub_dir)
@@ -3345,7 +3362,7 @@
 	dir->list[dir->count]->inode = inode_info;
 	dir->list[dir->count]->dir = sub_dir;
 	dir->list[dir->count++]->our_dir = dir;
-	dir->byte_count += strlen(name) + sizeof(squashfs_dir_entry);
+	dir->byte_count += strlen(name) + sizeof(struct squashfs_dir_entry);
 }
 
 
@@ -3371,7 +3388,8 @@
 {
 	struct dir_info *dir;
 
-	if((dir = malloc(sizeof(struct dir_info))) == NULL)
+	dir = malloc(sizeof(struct dir_info));
+	if(dir == NULL)
 		BAD_ERROR("Out of memory in scan1_opendir\n");
 
 	if(pathname[0] != '\0' && (dir->linuxdir = opendir(pathname)) == NULL) {
@@ -3390,27 +3408,30 @@
 
 int scan1_encomp_readdir(char *pathname, char *dir_name, struct dir_info *dir)
 {
-	int i, n, pass;
-	char *basename;
 	static int index = 0;
 
-	if(dir->count < old_root_entries)
+	if(dir->count < old_root_entries) {
+		int i;
+
 		for(i = 0; i < old_root_entries; i++) {
 			if(old_root_entry[i].inode.type == SQUASHFS_DIR_TYPE)
 				dir->directory_count ++;
 			add_dir_entry(old_root_entry[i].name, "", NULL,
 				&old_root_entry[i].inode, dir);
 		}
+	}
 
 	while(index < source) {
-		if((basename = getbase(source_path[index])) == NULL) {
+		char *basename = getbase(source_path[index]);
+		int n, pass = 1;
+
+		if(basename == NULL) {
 			ERROR("Bad source directory %s - skipping ...\n",
 				source_path[index]);
 			index ++;
 			continue;
 		}
 		strcpy(dir_name, basename);
-		pass = 1;
 		for(;;) {
 			for(n = 0; n < dir->count &&
 				strcmp(dir->list[n]->name, dir_name) != 0; n++);
@@ -3431,19 +3452,21 @@
 int scan1_single_readdir(char *pathname, char *dir_name, struct dir_info *dir)
 {
 	struct dirent *d_name;
-	int i, pass;
+	int i;
 
-	if(dir->count < old_root_entries)
+	if(dir->count < old_root_entries) {
 		for(i = 0; i < old_root_entries; i++) {
 			if(old_root_entry[i].inode.type == SQUASHFS_DIR_TYPE)
 				dir->directory_count ++;
 			add_dir_entry(old_root_entry[i].name, "", NULL,
 				&old_root_entry[i].inode, dir);
 		}
+	}
 
 	if((d_name = readdir(dir->linuxdir)) != NULL) {
+		int pass = 1;
+
 		strcpy(dir_name, d_name->d_name);
-		pass = 1;
 		for(;;) {
 			for(i = 0; i < dir->count &&
 				strcmp(dir->list[i]->name, dir_name) != 0; i++);
@@ -3465,9 +3488,9 @@
 
 int scan1_readdir(char *pathname, char *dir_name, struct dir_info *dir)
 {
-	struct dirent *d_name;
+	struct dirent *d_name = readdir(dir->linuxdir);
 
-	if((d_name = readdir(dir->linuxdir)) != NULL) {
+	if(d_name != NULL) {
 		strcpy(dir_name, d_name->d_name);
 		strcat(strcat(strcpy(pathname, dir->pathname), "/"),
 			d_name->d_name);
@@ -3558,7 +3581,8 @@
 
 	dir_scan2(dir_info, pseudo);
 
-	if((dir_ent = malloc(sizeof(struct dir_ent))) == NULL)
+	dir_ent = malloc(sizeof(struct dir_ent));
+	if(dir_ent == NULL)
 		BAD_ERROR("Out of memory in dir_scan\n");
 
 	if(pathname[0] == '\0') {
@@ -3614,17 +3638,18 @@
 struct dir_info *dir_scan1(char *pathname, struct pathnames *paths,
 	int (_readdir)(char *, char *, struct dir_info *))
 {
-	struct dir_info *dir, *sub_dir;
-	struct stat buf;
 	char filename[8192], dir_name[8192];
-	struct pathnames *new;
+	struct dir_info *dir = scan1_opendir(pathname);
 
-	if((dir = scan1_opendir(pathname)) == NULL) {
+	if(dir == NULL) {
 		ERROR("Could not open %s, skipping...\n", pathname);
 		goto error;
 	}
 
 	while(_readdir(filename, dir_name, dir) != FALSE) {
+		struct dir_info *sub_dir;
+		struct stat buf;
+		struct pathnames *new;
 
 		if(strcmp(dir_name, ".") == 0 || strcmp(dir_name, "..") == 0)
 			continue;
@@ -4059,7 +4084,8 @@
 #endif
 	}
 
-	if((thread = malloc((2 + processors * 2) * sizeof(pthread_t))) == NULL)
+	thread = malloc((2 + processors * 2) * sizeof(pthread_t));
+	if(thread == NULL)
 		BAD_ERROR("Out of memory allocating thread descriptors\n");
 	deflator_thread = &thread[2];
 	frag_deflator_thread = &deflator_thread[processors];
@@ -4170,7 +4196,8 @@
 	target = get_component(target, targname);
 
 	if(paths == NULL) {
-		if((paths = malloc(sizeof(struct pathname))) == NULL)
+		paths = malloc(sizeof(struct pathname));
+		if(paths == NULL)
 			BAD_ERROR("failed to allocate paths\n");
 
 		paths->names = 0;
@@ -4375,7 +4402,7 @@
 #define RECOVER_ID "Squashfs recovery file v1.0\n"
 #define RECOVER_ID_SIZE 28
 
-void write_recovery_data(squashfs_super_block *sBlk)
+void write_recovery_data(struct squashfs_super_block *sBlk)
 {
 	int res, recoverfd, bytes = sBlk->bytes_used - sBlk->inode_table_start;
 	pid_t pid = getpid();
@@ -4388,7 +4415,8 @@
 		return;
 	}
 
-	if((metadata = malloc(bytes)) == NULL)
+	metadata = malloc(bytes);
+	if(metadata == NULL)
 		BAD_ERROR("Failed to alloc metadata buffer in "
 			"write_recovery_data\n");
 
@@ -4407,7 +4435,7 @@
 		BAD_ERROR("Failed to write recovery file, because %s\n",
 			strerror(errno));
 
-	if(write_bytes(recoverfd, sBlk, sizeof(squashfs_super_block)) == -1)
+	if(write_bytes(recoverfd, sBlk, sizeof(struct squashfs_super_block)) == -1)
 		BAD_ERROR("Failed to write recovery file, because %s\n",
 			strerror(errno));
 
@@ -4429,14 +4457,15 @@
 void read_recovery_data(char *recovery_file, char *destination_file)
 {
 	int fd, recoverfd, bytes;
-	squashfs_super_block orig_sBlk, sBlk;
+	struct squashfs_super_block orig_sBlk, sBlk;
 	char *metadata;
 	int res;
 	struct stat buf;
 	char header[] = RECOVER_ID;
 	char header2[RECOVER_ID_SIZE];
 
-	if((recoverfd = open(recovery_file, O_RDONLY)) == -1)
+	recoverfd = open(recovery_file, O_RDONLY);
+	if(recoverfd == -1)
 		BAD_ERROR("Failed to open recovery file because %s\n",
 			strerror(errno));
 
@@ -4444,7 +4473,8 @@
 		BAD_ERROR("Failed to stat destination file, because %s\n",
 			strerror(errno));
 
-	if((fd = open(destination_file, O_RDWR)) == -1)
+	fd = open(destination_file, O_RDWR);
+	if(fd == -1)
 		BAD_ERROR("Failed to open destination file because %s\n",
 			strerror(errno));
 
@@ -4457,25 +4487,26 @@
 	if(strncmp(header, header2, RECOVER_ID_SIZE) !=0 )
 		BAD_ERROR("Not a recovery file\n");
 
-	res = read_bytes(recoverfd, &sBlk, sizeof(squashfs_super_block));
+	res = read_bytes(recoverfd, &sBlk, sizeof(struct squashfs_super_block));
 	if(res == -1)
 		BAD_ERROR("Failed to read recovery file, because %s\n",
 			strerror(errno));
-	if(res < sizeof(squashfs_super_block))
+	if(res < sizeof(struct squashfs_super_block))
 		BAD_ERROR("Recovery file appears to be truncated\n");
 
-	res = read_fs_bytes(fd, 0, sizeof(squashfs_super_block), &orig_sBlk);
+	res = read_fs_bytes(fd, 0, sizeof(struct squashfs_super_block), &orig_sBlk);
 	if(res == 0)
 		EXIT_MKSQUASHFS();
 
 	if(memcmp(((char *) &sBlk) + 4, ((char *) &orig_sBlk) + 4,
-			sizeof(squashfs_super_block) - 4) != 0)
+			sizeof(struct squashfs_super_block) - 4) != 0)
 		BAD_ERROR("Recovery file and destination file do not seem to "
 			"match\n");
 
 	bytes = sBlk.bytes_used - sBlk.inode_table_start;
 
-	if((metadata = malloc(bytes)) == NULL)
+	metadata = malloc(bytes);
+	if(metadata == NULL)
 		BAD_ERROR("Failed to alloc metadata buffer in "
 			"read_recovery_data\n");
 
@@ -4486,7 +4517,7 @@
 	if(res < bytes)
 		BAD_ERROR("Recovery file appears to be truncated\n");
 
-	write_destination(fd, 0, sizeof(squashfs_super_block), (char *) &sBlk);
+	write_destination(fd, 0, sizeof(struct squashfs_super_block), &sBlk);
 
 	write_destination(fd, sBlk.inode_table_start, bytes, metadata);
 
@@ -4501,7 +4532,7 @@
 
 
 #define VERSION() \
-	printf("mksquashfs version 4.1 (2010/09/19)\n");\
+	printf("mksquashfs version 4.1-CVS (2010/12/31)\n");\
 	printf("copyright (C) 2010 Phillip Lougher "\
 		"<phillip@lougher.demon.co.uk>\n\n"); \
 	printf("This program is free software; you can redistribute it and/or"\
@@ -4521,15 +4552,14 @@
 int main(int argc, char *argv[])
 {
 	struct stat buf, source_buf;
-	int i;
-	squashfs_super_block sBlk;
+	int res, i;
+	struct squashfs_super_block sBlk;
 	char *b, *root_name = NULL;
 	int nopad = FALSE, keep_as_directory = FALSE;
 	squashfs_inode inode;
 	int readb_mbytes = READER_BUFFER_DEFAULT,
 		writeb_mbytes = WRITER_BUFFER_DEFAULT,
 		fragmentb_mbytes = FRAGMENT_BUFFER_DEFAULT;
-	int s_minor = SQUASHFS_MINOR;
 
 	pthread_mutex_init(&progress_mutex, NULL);
 	block_log = slog(block_size);
@@ -4542,14 +4572,50 @@
 		goto printOptions;
 	source_path = argv + 1;
 	source = i - 2;
+	/*
+	 * lookup default compressor.  Note the Makefile ensures the default
+	 * compressor has been built, and so we don't need to to check
+	 * for failure here
+	 */
+	comp = lookup_compressor(COMP_DEFAULT);
 	for(; i < argc; i++) {
 		if(strcmp(argv[i], "-comp") == 0) {
+			if(compressor_opts_parsed) {
+				ERROR("%s: -comp must appear before -X options"
+					"\n", argv[0]);
+				exit(1);
+			}
 			if(++i == argc) {
 				ERROR("%s: -comp missing compression type\n",
 					argv[0]);
 				exit(1);
 			}
-			comp_name = argv[i];
+			comp = lookup_compressor(argv[i]);
+			if(!comp->supported) {
+				ERROR("%s: Compressor \"%s\" is not supported!"
+					"\n", argv[0], argv[i]);
+				ERROR("%s: Compressors available:\n", argv[0]);
+				display_compressors("", COMP_DEFAULT);
+				exit(1);
+			}
+
+		} else if(strncmp(argv[i], "-X", 2) == 0) {
+			int args = compressor_options(comp, argv + i, argc - i);
+			if(args < 0) {
+				if(args == -1) {
+					ERROR("%s: Unrecognised compressor"
+						" option %s\n", argv[0],
+						argv[i]);
+					ERROR("%s: Did you forget to specify"
+						" -comp, or specify it after"
+						" the compressor specific"
+						" option?\n", argv[0]);
+					}
+				exit(1);
+			}
+			i += args;
+			compressor_opts_parsed = 1;
+
 		} else if(strcmp(argv[i], "-pf") == 0) {
 			if(++i == argc) {
 				ERROR("%s: -pf missing filename\n", argv[0]);
@@ -4857,7 +4923,7 @@
 			ERROR("-write-queue <size>\tSet output queue to <size> "
 				"Mbytes.  Default %d Mbytes\n",
 				WRITER_BUFFER_DEFAULT);
-			ERROR("-fragment-queue <size>\tSet fagment queue to "
+			ERROR("-fragment-queue <size>\tSet fragment queue to "
 				"<size> Mbytes.  Default %d Mbytes\n",
 				FRAGMENT_BUFFER_DEFAULT);
 			ERROR("\nMiscellaneous options:\n");
@@ -4871,12 +4937,21 @@
 				"-noF\n");
 			ERROR("-noXattrCompression\talternative name for "
 				"-noX\n");
-			ERROR("\nCompressors available:\n");
-			display_compressors("", COMP_DEFAULT);
+			ERROR("\nCompressors available and compressor specific "
+				"options:\n");
+			display_compressor_usage(COMP_DEFAULT);
 			exit(1);
 		}
 	}
 
+	/*
+	 * Some compressors may need the options to be checked for validity
+	 * once all the options have been processed
+	 */
+	res = compressor_options_post(comp, block_size);
+	if(res)
+		EXIT_MKSQUASHFS();
+
 	for(i = 0; i < source; i++)
 		if(lstat(source_path[i], &source_buf) == -1) {
 			fprintf(stderr, "Cannot stat source directory \"%s\" "
@@ -4997,31 +5072,49 @@
 		}
 
 		block_log = slog(block_size = sBlk.block_size);
-		s_minor = sBlk.s_minor;
 		noI = SQUASHFS_UNCOMPRESSED_INODES(sBlk.flags);
 		noD = SQUASHFS_UNCOMPRESSED_DATA(sBlk.flags);
 		noF = SQUASHFS_UNCOMPRESSED_FRAGMENTS(sBlk.flags);
+		noX = SQUASHFS_UNCOMPRESSED_XATTRS(sBlk.flags);
 		no_fragments = SQUASHFS_NO_FRAGMENTS(sBlk.flags);
 		always_use_fragments = SQUASHFS_ALWAYS_FRAGMENTS(sBlk.flags);
 		duplicate_checking = SQUASHFS_DUPLICATES(sBlk.flags);
 		exportable = SQUASHFS_EXPORTABLE(sBlk.flags);
-	} else {
-		comp = lookup_compressor(comp_name);
-		if(!comp->supported) {
-			ERROR("FATAL_ERROR: Compressor \"%s\" is not "
-				"supported!\n", comp_name);
-			ERROR("Compressors available:\n");
-			display_compressors("", COMP_DEFAULT);
-			EXIT_MKSQUASHFS();
-		}
+		no_xattrs = SQUASHFS_NO_XATTRS(sBlk.flags);
+		comp_opts = SQUASHFS_COMP_OPTS(sBlk.flags);
 	}
 
 	initialise_threads(readb_mbytes, writeb_mbytes, fragmentb_mbytes);
 
+	res = compressor_init(comp, &stream, SQUASHFS_METADATA_SIZE, 0);
+	if(res)
+		BAD_ERROR("compressor_init failed\n");
+
 	if(delete) {
+		int size;
+		void *comp_data = compressor_dump_options(comp, &size);
+
 		printf("Creating %d.%d filesystem on %s, block size %d.\n",
-			SQUASHFS_MAJOR, s_minor, argv[source + 1], block_size);
-		bytes = sizeof(squashfs_super_block);
+			SQUASHFS_MAJOR, SQUASHFS_MINOR, argv[source + 1], block_size);
+
+		/*
+		 * store any compressor specific options after the superblock,
+		 * and set the COMP_OPT flag to show that the filesystem has
+		 * compressor specfic options
+		 */
+		if(comp_data) {
+			unsigned short c_byte = size | SQUASHFS_COMPRESSED_BIT;
+	
+			SQUASHFS_INSWAP_SHORTS(&c_byte, 1);
+			write_destination(fd, sizeof(struct squashfs_super_block),
+				sizeof(c_byte), &c_byte);
+			write_destination(fd, sizeof(struct squashfs_super_block) +
+				sizeof(c_byte), size, comp_data);
+			bytes = sizeof(struct squashfs_super_block) + sizeof(c_byte)
+				+ size;
+			comp_opts = TRUE;
+		} else			
+			bytes = sizeof(struct squashfs_super_block);
 	} else {
 		unsigned int last_directory_block, inode_dir_offset,
 			inode_dir_file_size, root_inode_size,
@@ -5053,15 +5146,15 @@
 		if((fragments = sBlk.fragments)) {
 			fragment_table = realloc((char *) fragment_table,
 				((fragments + FRAG_SIZE - 1) & ~(FRAG_SIZE - 1))
-				 * sizeof(squashfs_fragment_entry)); 
+				 * sizeof(struct squashfs_fragment_entry)); 
 			if(fragment_table == NULL)
 				BAD_ERROR("Out of memory in save filesystem state\n");
 		}
 
 		printf("Appending to existing %d.%d filesystem on %s, block "
-			"size %d\n", SQUASHFS_MAJOR, s_minor, argv[source + 1],
+			"size %d\n", SQUASHFS_MAJOR, SQUASHFS_MINOR, argv[source + 1],
 			block_size);
-		printf("All -b, -noI, -noD, -noF, no-duplicates, no-fragments, "
+		printf("All -b, -noI, -noD, -noF, -noX, no-duplicates, no-fragments, "
 			"-always-use-fragments,\n-exportable and -comp options "
 			"ignored\n");
 		printf("\nIf appending is not wanted, please re-run with "
@@ -5192,11 +5285,12 @@
 	sBlk.inodes = inode_count;
 	sBlk.s_magic = SQUASHFS_MAGIC;
 	sBlk.s_major = SQUASHFS_MAJOR;
-	sBlk.s_minor = s_minor;
+	sBlk.s_minor = SQUASHFS_MINOR;
 	sBlk.block_size = block_size;
 	sBlk.block_log = block_log;
-	sBlk.flags = SQUASHFS_MKFLAGS(noI, noD, noF, no_fragments,
-		always_use_fragments, duplicate_checking, exportable);
+	sBlk.flags = SQUASHFS_MKFLAGS(noI, noD, noF, noX, no_fragments,
+		always_use_fragments, duplicate_checking, exportable,
+		no_xattrs, comp_opts);
 	sBlk.mkfs_time = time(NULL);
 
 restore_filesystem:
@@ -5242,8 +5336,7 @@
 	sBlk.compression = comp->id;
 
 	SQUASHFS_INSWAP_SUPER_BLOCK(&sBlk); 
-	write_destination(fd, SQUASHFS_START, sizeof(squashfs_super_block),
-		(char *) &sBlk);
+	write_destination(fd, SQUASHFS_START, sizeof(sBlk), &sBlk);
 
 	if(!nopad && (i = bytes & (4096 - 1))) {
 		char temp[4096] = {0};
@@ -5258,7 +5351,7 @@
 		unlink(recovery_file);
 
 	total_bytes += total_inode_bytes + total_directory_bytes +
-		sizeof(squashfs_super_block) + total_xattr_bytes;
+		sizeof(struct squashfs_super_block) + total_xattr_bytes;
 
 	printf("\n%sSquashfs %d.%d filesystem, %s compressed, data block size"
 		" %d\n", exportable ? "Exportable " : "", SQUASHFS_MAJOR,
diff -aurN squashfs4.1.old/squashfs-tools/read_fs.c squashfs4.1.new/squashfs-tools/read_fs.c
--- squashfs4.1.old/squashfs-tools/read_fs.c	2010-09-16 02:51:53.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/read_fs.c	2010-12-31 21:32:17.000000000 +0000
@@ -59,7 +59,6 @@
 #include "squashfs_fs.h"
 #include "squashfs_swap.h"
 #include "read_fs.h"
-#include "global.h"
 #include "compressor.h"
 #include "xattr.h"
 
@@ -75,7 +74,7 @@
 int read_block(int fd, long long start, long long *next, void *block)
 {
 	unsigned short c_byte;
-	int res, offset = 2;
+	int res;
 	
 	res = read_fs_bytes(fd, start, 2, &c_byte);
 	if(res == 0)
@@ -88,11 +87,11 @@
 		int error, res;
 
 		c_byte = SQUASHFS_COMPRESSED_SIZE(c_byte);
-		res = read_fs_bytes(fd, start + offset, c_byte, buffer);
+		res = read_fs_bytes(fd, start + 2, c_byte, buffer);
 		if(res == 0)
 			return 0;
 
-		res = comp->uncompress(block, buffer, c_byte,
+		res = compressor_uncompress(comp, block, buffer, c_byte,
 			SQUASHFS_METADATA_SIZE, &error);
 		if(res == -1) {
 			ERROR("%s uncompress failed with error code %d\n",
@@ -100,16 +99,16 @@
 			return 0;
 		}
 		if(next)
-			*next = start + offset + c_byte;
+			*next = start + 2 + c_byte;
 		return res;
 	} else {
 		c_byte = SQUASHFS_COMPRESSED_SIZE(c_byte);
-		res = read_fs_bytes(fd, start + offset, c_byte, block);
+		res = read_fs_bytes(fd, start + 2, c_byte, block);
 		if(res == 0)
 			return 0;
 
 		if(next)
-			*next = start + offset + c_byte;
+			*next = start + 2 + c_byte;
 		return c_byte;
 	}
 }
@@ -117,7 +116,7 @@
 
 int scan_inode_table(int fd, long long start, long long end,
 	long long root_inode_start, int root_inode_offset,
-	squashfs_super_block *sBlk, squashfs_inode_header *dir_inode,
+	struct squashfs_super_block *sBlk, union squashfs_inode_header *dir_inode,
 	unsigned char **inode_table, unsigned int *root_inode_block,
 	unsigned int *root_inode_size, long long *uncompressed_file,
 	unsigned int *uncompressed_directory, int *file_count, int *sym_count,
@@ -126,7 +125,7 @@
 {
 	unsigned char *cur_ptr;
 	int byte, bytes = 0, size = 0, files = 0;
-	squashfs_reg_inode_header inode;
+	struct squashfs_reg_inode_header inode;
 	unsigned int directory_start_block;
 
 	TRACE("scan_inode_table: start 0x%llx, end 0x%llx, root_inode_start "
@@ -233,7 +232,7 @@
 				break;
 			}	
 			case SQUASHFS_LREG_TYPE: {
-				squashfs_lreg_inode_header inode;
+				struct squashfs_lreg_inode_header inode;
 				int frag_bytes;
 				int blocks;
 				long long file_bytes = 0;
@@ -284,7 +283,7 @@
 			}	
 			case SQUASHFS_SYMLINK_TYPE:
 			case SQUASHFS_LSYMLINK_TYPE: {
-				squashfs_symlink_inode_header inodep;
+				struct squashfs_symlink_inode_header inodep;
 	
 				SQUASHFS_SWAP_SYMLINK_INODE_HEADER(&inodep,
 					cur_ptr);
@@ -297,7 +296,7 @@
 				break;
 			}
 			case SQUASHFS_DIR_TYPE: {
-				squashfs_dir_inode_header dir_inode;
+				struct squashfs_dir_inode_header dir_inode;
 
 				SQUASHFS_SWAP_DIR_INODE_HEADER(&dir_inode,
 					cur_ptr);
@@ -305,11 +304,11 @@
 					*uncompressed_directory +=
 					dir_inode.file_size;
 				(*dir_count) ++;
-				cur_ptr += sizeof(squashfs_dir_inode_header);
+				cur_ptr += sizeof(struct squashfs_dir_inode_header);
 				break;
 			}
 			case SQUASHFS_LDIR_TYPE: {
-				squashfs_ldir_inode_header dir_inode;
+				struct squashfs_ldir_inode_header dir_inode;
 				int i;
 
 				SQUASHFS_SWAP_LDIR_INODE_HEADER(&dir_inode,
@@ -318,13 +317,13 @@
 					*uncompressed_directory +=
 					dir_inode.file_size;
 				(*dir_count) ++;
-				cur_ptr += sizeof(squashfs_ldir_inode_header);
+				cur_ptr += sizeof(struct squashfs_ldir_inode_header);
 				for(i = 0; i < dir_inode.i_count; i++) {
-					squashfs_dir_index index;
+					struct squashfs_dir_index index;
 
 					SQUASHFS_SWAP_DIR_INDEX(&index,
 						cur_ptr);
-					cur_ptr += sizeof(squashfs_dir_index) +
+					cur_ptr += sizeof(struct squashfs_dir_index) +
 						index.size + 1;
 				}
 				break;
@@ -332,28 +331,28 @@
 		 	case SQUASHFS_BLKDEV_TYPE:
 		 	case SQUASHFS_CHRDEV_TYPE:
 				(*dev_count) ++;
-				cur_ptr += sizeof(squashfs_dev_inode_header);
+				cur_ptr += sizeof(struct squashfs_dev_inode_header);
 				break;
 		 	case SQUASHFS_LBLKDEV_TYPE:
 		 	case SQUASHFS_LCHRDEV_TYPE:
 				(*dev_count) ++;
-				cur_ptr += sizeof(squashfs_ldev_inode_header);
+				cur_ptr += sizeof(struct squashfs_ldev_inode_header);
 				break;
 			case SQUASHFS_FIFO_TYPE:
 				(*fifo_count) ++;
-				cur_ptr += sizeof(squashfs_ipc_inode_header);
+				cur_ptr += sizeof(struct squashfs_ipc_inode_header);
 				break;
 			case SQUASHFS_LFIFO_TYPE:
 				(*fifo_count) ++;
-				cur_ptr += sizeof(squashfs_lipc_inode_header);
+				cur_ptr += sizeof(struct squashfs_lipc_inode_header);
 				break;
 			case SQUASHFS_SOCKET_TYPE:
 				(*sock_count) ++;
-				cur_ptr += sizeof(squashfs_ipc_inode_header);
+				cur_ptr += sizeof(struct squashfs_ipc_inode_header);
 				break;
 			case SQUASHFS_LSOCKET_TYPE:
 				(*sock_count) ++;
-				cur_ptr += sizeof(squashfs_lipc_inode_header);
+				cur_ptr += sizeof(struct squashfs_lipc_inode_header);
 				break;
 		 	default:
 				ERROR("Unknown inode type %d in "
@@ -363,7 +362,8 @@
 		}
 	}
 	
-	return files;
+	printf("Read existing filesystem, %d inodes scanned\n", files);
+	return TRUE;
 
 
 failed:
@@ -372,11 +372,12 @@
 }
 
 
-struct compressor *read_super(int fd, squashfs_super_block *sBlk, char *source)
+struct compressor *read_super(int fd, struct squashfs_super_block *sBlk, char *source)
 {
-	int res;
+	int res, bytes = 0;
+	char buffer[SQUASHFS_METADATA_SIZE] __attribute__ ((aligned));
 
-	res = read_fs_bytes(fd, SQUASHFS_START, sizeof(squashfs_super_block),
+	res = read_fs_bytes(fd, SQUASHFS_START, sizeof(struct squashfs_super_block),
 		sBlk);
 	if(res == 0)
 		goto failed_mount;
@@ -414,10 +415,35 @@
 	if(!comp->supported) {
 		ERROR("Filesystem on %s uses %s compression, this is"
 			"unsupported by this version\n", source, comp->name);
+		ERROR("Compressors available:\n");
 		display_compressors("", "");
 		goto failed_mount;
 	}
 
+	/*
+	 * Read extended superblock information from disk.
+	 *
+	 * Read compressor specific options from disk if present, and pass
+	 * to compressor to set compressor options.
+	 *
+	 * Note, if there's no compressor options present, the compressor
+	 * is still called to set the default options (the defaults may have
+	 * been changed by the user specifying options on the command
+	 * line which need to be over-ridden).
+	 */
+	if(SQUASHFS_COMP_OPTS(sBlk->flags)) {
+		bytes = read_block(fd, sizeof(*sBlk), NULL, buffer);
+
+		if(bytes == 0)
+			goto failed_mount;
+	}
+
+	res = compressor_extract_options(comp, sBlk->block_size, buffer, bytes);
+	if(res == -1) {
+		ERROR("Compressor failed to set compressor options\n");
+		goto failed_mount;
+	}
+
 	printf("Found a valid %sSQUASHFS superblock on %s.\n",
 		SQUASHFS_EXPORTABLE(sBlk->flags) ? "exportable " : "", source);
 	printf("\tCompression used %s\n", comp->name);
@@ -427,12 +453,16 @@
 		SQUASHFS_UNCOMPRESSED_DATA(sBlk->flags) ? "un" : "");
 	printf("\tFragments are %scompressed\n",
 		SQUASHFS_UNCOMPRESSED_FRAGMENTS(sBlk->flags) ? "un" : "");
+	printf("\tXattrs are %scompressed\n",
+		SQUASHFS_UNCOMPRESSED_XATTRS(sBlk->flags) ? "un" : "");
 	printf("\tFragments are %spresent in the filesystem\n",
 		SQUASHFS_NO_FRAGMENTS(sBlk->flags) ? "not " : "");
 	printf("\tAlways_use_fragments option is %sspecified\n",
 		SQUASHFS_ALWAYS_FRAGMENTS(sBlk->flags) ? "" : "not ");
 	printf("\tDuplicates are %sremoved\n",
 		SQUASHFS_DUPLICATES(sBlk->flags) ? "" : "not ");
+	printf("\tXattrs are %sstored\n",
+		SQUASHFS_NO_XATTRS(sBlk->flags) ? "not " : "");
 	printf("\tFilesystem size %.2f Kbytes (%.2f Mbytes)\n",
 		sBlk->bytes_used / 1024.0, sBlk->bytes_used
 		/ (1024.0 * 1024.0));
@@ -458,13 +488,13 @@
 
 unsigned char *squashfs_readdir(int fd, int root_entries,
 	unsigned int directory_start_block, int offset, int size,
-	unsigned int *last_directory_block, squashfs_super_block *sBlk,
+	unsigned int *last_directory_block, struct squashfs_super_block *sBlk,
 	void (push_directory_entry)(char *, squashfs_inode, int, int))
 {
-	squashfs_dir_header dirh;
-	char buffer[sizeof(squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]
+	struct squashfs_dir_header dirh;
+	char buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]
 		__attribute__ ((aligned));
-	squashfs_dir_entry *dire = (squashfs_dir_entry *) buffer;
+	struct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;
 	unsigned char *directory_table = NULL;
 	int byte, bytes = 0, dir_count;
 	long long start = sBlk->directory_table_start + directory_start_block,
@@ -524,7 +554,7 @@
 }
 
 
-unsigned int *read_id_table(int fd, squashfs_super_block *sBlk)
+unsigned int *read_id_table(int fd, struct squashfs_super_block *sBlk)
 {
 	int indexes = SQUASHFS_ID_BLOCKS(sBlk->no_ids);
 	long long index[indexes];
@@ -572,11 +602,11 @@
 }
 
 
-int read_fragment_table(int fd, squashfs_super_block *sBlk,
-	squashfs_fragment_entry **fragment_table)
+int read_fragment_table(int fd, struct squashfs_super_block *sBlk,
+	struct squashfs_fragment_entry **fragment_table)
 {
 	int res, i, indexes = SQUASHFS_FRAGMENT_INDEXES(sBlk->fragments);
-	squashfs_fragment_index fragment_table_index[indexes];
+	long long fragment_table_index[indexes];
 
 	TRACE("read_fragment_table: %d fragments, reading %d fragment indexes "
 		"from 0x%llx\n", sBlk->fragments, indexes,
@@ -585,7 +615,7 @@
 		return 1;
 
 	*fragment_table = malloc(sBlk->fragments *
-		sizeof(squashfs_fragment_entry));
+		sizeof(struct squashfs_fragment_entry));
 	if(*fragment_table == NULL) {
 		ERROR("Failed to allocate fragment table\n");
 		return 0;
@@ -623,7 +653,7 @@
 }
 
 
-int read_inode_lookup_table(int fd, squashfs_super_block *sBlk,
+int read_inode_lookup_table(int fd, struct squashfs_super_block *sBlk,
 	squashfs_inode **inode_lookup_table)
 {
 	int lookup_bytes = SQUASHFS_LOOKUP_BYTES(sBlk->inodes);
@@ -670,7 +700,7 @@
 }
 
 
-long long read_filesystem(char *root_name, int fd, squashfs_super_block *sBlk,
+long long read_filesystem(char *root_name, int fd, struct squashfs_super_block *sBlk,
 	char **cinode_table, char **data_cache, char **cdirectory_table,
 	char **directory_data_cache, unsigned int *last_directory_block,
 	unsigned int *inode_dir_offset, unsigned int *inode_dir_file_size,
@@ -681,7 +711,7 @@
 	unsigned int *inode_dir_inode_number,
 	unsigned int *inode_dir_parent_inode,
 	void (push_directory_entry)(char *, squashfs_inode, int, int),
-	squashfs_fragment_entry **fragment_table,
+	struct squashfs_fragment_entry **fragment_table,
 	squashfs_inode **inode_lookup_table)
 {
 	unsigned char *inode_table = NULL, *directory_table;
@@ -691,8 +721,8 @@
 		SQUASHFS_INODE_BLK(sBlk->root_inode);
 	unsigned int root_inode_offset =
 		SQUASHFS_INODE_OFFSET(sBlk->root_inode);
-	unsigned int root_inode_block, files;
-	squashfs_inode_header inode;
+	unsigned int root_inode_block;
+	union squashfs_inode_header inode;
 	unsigned int *id_table;
 	int res;
 
@@ -711,20 +741,18 @@
 	if(id_table == NULL)
 		goto error;
 
-	if((files = scan_inode_table(fd, start, end, root_inode_start,
-			root_inode_offset, sBlk, &inode, &inode_table,
-			&root_inode_block, root_inode_size, uncompressed_file,
-			uncompressed_directory, file_count, sym_count,
-			dev_count, dir_count, fifo_count, sock_count, id_table))
-			== 0) {
+	res = scan_inode_table(fd, start, end, root_inode_start,
+		root_inode_offset, sBlk, &inode, &inode_table,
+		&root_inode_block, root_inode_size, uncompressed_file,
+		uncompressed_directory, file_count, sym_count, dev_count,
+		dir_count, fifo_count, sock_count, id_table);
+	if(res == 0) {
 		ERROR("read_filesystem: inode table read failed\n");
 		goto error;
 	}
 
 	*uncompressed_inode = root_inode_block;
 
-	printf("Read existing filesystem, %d inodes scanned\n", files);
-
 	if(inode.base.inode_type == SQUASHFS_DIR_TYPE ||
 			inode.base.inode_type == SQUASHFS_LDIR_TYPE) {
 		if(inode.base.inode_type == SQUASHFS_DIR_TYPE) {
diff -aurN squashfs4.1.old/squashfs-tools/read_xattrs.c squashfs4.1.new/squashfs-tools/read_xattrs.c
--- squashfs4.1.old/squashfs-tools/read_xattrs.c	2010-07-22 05:16:38.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/read_xattrs.c	2010-12-31 21:32:17.000000000 +0000
@@ -42,7 +42,6 @@
 #include "squashfs_fs.h"
 #include "squashfs_swap.h"
 #include "read_fs.h"
-#include "global.h"
 #include "xattr.h"
 
 #include <stdlib.h>
@@ -168,7 +167,7 @@
  * Read and decompress the xattr id table and the xattr metadata.
  * This is cached in memory for later use by get_xattr()
  */
-int read_xattrs_from_disk(int fd, squashfs_super_block *sBlk)
+int read_xattrs_from_disk(int fd, struct squashfs_super_block *sBlk)
 {
 	int res, bytes, i, indexes, index_bytes, ids;
 	long long *index, start, end;
diff -aurN squashfs4.1.old/squashfs-tools/sort.c squashfs4.1.new/squashfs-tools/sort.c
--- squashfs4.1.old/squashfs-tools/sort.c	2010-07-22 05:17:56.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/sort.c	2010-12-31 21:32:17.000000000 +0000
@@ -36,7 +36,6 @@
 #include <stdlib.h>
 
 #include "squashfs_fs.h"
-#include "global.h"
 #include "mksquashfs.h"
 #include "sort.h"
 
diff -aurN squashfs4.1.old/squashfs-tools/squashfs_compat.h squashfs4.1.new/squashfs-tools/squashfs_compat.h
--- squashfs4.1.old/squashfs-tools/squashfs_compat.h	2010-08-25 18:21:22.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/squashfs_compat.h	2010-12-31 10:08:38.000000000 +0000
@@ -51,7 +51,7 @@
 	unsigned int		no_uids:8;
 	unsigned int		no_guids:8;
 	unsigned int		mkfs_time /* time of filesystem creation */;
-	squashfs_inode_t	root_inode;
+	squashfs_inode		root_inode;
 	unsigned int		block_size;
 	unsigned int		fragments;
 	unsigned int		fragment_table_start_2;
@@ -103,7 +103,7 @@
 
 struct squashfs_reg_inode_header_3 {
 	SQUASHFS_BASE_INODE_HEADER_3;
-	squashfs_block_t	start_block;
+	squashfs_block		start_block;
 	unsigned int		fragment;
 	unsigned int		offset;
 	unsigned int		file_size;
@@ -113,7 +113,7 @@
 struct squashfs_lreg_inode_header_3 {
 	SQUASHFS_BASE_INODE_HEADER_3;
 	unsigned int		nlink;
-	squashfs_block_t	start_block;
+	squashfs_block		start_block;
 	unsigned int		fragment;
 	unsigned int		offset;
 	long long		file_size;
@@ -185,7 +185,6 @@
 typedef struct squashfs_dir_entry_3 squashfs_dir_entry_3;
 typedef struct squashfs_dir_header_3 squashfs_dir_header_3;
 typedef struct squashfs_fragment_entry_3 squashfs_fragment_entry_3;
-typedef union squashfs_inode_header_3 squashfs_inode_header_3;
 
 /*
  * macros to convert each packed bitfield structure from little endian to big
@@ -483,7 +482,6 @@
 typedef struct squashfs_symlink_inode_header_1 squashfs_symlink_inode_header_1;
 typedef struct squashfs_reg_inode_header_1 squashfs_reg_inode_header_1;
 typedef struct squashfs_dir_inode_header_1 squashfs_dir_inode_header_1;
-typedef union squashfs_inode_header_1 squashfs_inode_header_1;
 
 #define SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, n) \
 	SQUASHFS_MEMSET(s, d, n);\
@@ -655,7 +653,6 @@
 typedef struct squashfs_dir_entry_2 squashfs_dir_entry_2;
 typedef struct squashfs_dir_header_2 squashfs_dir_header_2;
 typedef struct squashfs_fragment_entry_2 squashfs_fragment_entry_2;
-typedef union squashfs_inode_header_2 squashfs_inode_header_2;
 
 #define SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, n)\
 	SQUASHFS_MEMSET(s, d, n);\
diff -aurN squashfs4.1.old/squashfs-tools/squashfs_fs.h squashfs4.1.new/squashfs-tools/squashfs_fs.h
--- squashfs4.1.old/squashfs-tools/squashfs_fs.h	2010-09-16 03:04:43.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/squashfs_fs.h	2010-12-31 09:25:42.000000000 +0000
@@ -61,6 +61,9 @@
 #define SQUASHFS_ALWAYS_FRAG		5
 #define SQUASHFS_DUPLICATE		6
 #define SQUASHFS_EXPORT			7
+#define SQUASHFS_NOX			8
+#define SQUASHFS_NO_XATTR		9
+#define SQUASHFS_COMP_OPT		10
 
 #define SQUASHFS_BIT(flag, bit)		((flag >> bit) & 1)
 
@@ -85,10 +88,21 @@
 #define SQUASHFS_EXPORTABLE(flags)		SQUASHFS_BIT(flags, \
 						SQUASHFS_EXPORT)
 
-#define SQUASHFS_MKFLAGS(noi, nod, nof, no_frag, always_frag, \
-		duplicate_checking, exportable)	(noi | (nod << 1) | \
-		(nof << 3) | (no_frag << 4) | (always_frag << 5) | \
-		(duplicate_checking << 6) | (exportable << 7))
+#define SQUASHFS_UNCOMPRESSED_XATTRS(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_NOX)
+
+#define SQUASHFS_NO_XATTRS(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_NO_XATTR)
+
+#define SQUASHFS_COMP_OPTS(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_COMP_OPT)
+
+#define SQUASHFS_MKFLAGS(noi, nod, nof, nox, no_frag, always_frag, \
+		duplicate_checking, exportable, no_xattr, comp_opt) (noi | \
+		(nod << 1) | (nof << 3) | (no_frag << 4) | \
+		(always_frag << 5) | (duplicate_checking << 6) | \
+		(exportable << 7) | (nox << 8) | (no_xattr << 9) | \
+		(comp_opt << 10))
 
 /* Max number of types and file types */
 #define SQUASHFS_DIR_TYPE		1
@@ -137,7 +151,7 @@
 
 #define SQUASHFS_INODE_OFFSET(a)	((unsigned int) ((a) & 0xffff))
 
-#define SQUASHFS_MKINODE(A, B)		((squashfs_inode_t)(((squashfs_inode_t) (A)\
+#define SQUASHFS_MKINODE(A, B)		((squashfs_inode)(((squashfs_inode) (A)\
 					<< 16) + (B)))
 
 /* Compute 32 bit VFS inode number from squashfs inode number */
@@ -164,7 +178,7 @@
 						sizeof(long long))
 
 /* inode lookup table defines */
-#define SQUASHFS_LOOKUP_BYTES(A)	((A) * sizeof(squashfs_inode_t))
+#define SQUASHFS_LOOKUP_BYTES(A)	((A) * sizeof(squashfs_inode))
 
 #define SQUASHFS_LOOKUP_BLOCK(A)		(SQUASHFS_LOOKUP_BYTES(A) / \
 						SQUASHFS_METADATA_SIZE)
@@ -253,12 +267,13 @@
  * definitions for structures on disk
  */
 
-typedef long long		squashfs_block_t;
-typedef long long		squashfs_inode_t;
+typedef long long		squashfs_block;
+typedef long long		squashfs_inode;
 
 #define ZLIB_COMPRESSION	1
 #define LZMA_COMPRESSION	2
 #define LZO_COMPRESSION		3
+#define XZ_COMPRESSION		4
 
 struct squashfs_super_block {
 	unsigned int		s_magic;
@@ -272,7 +287,7 @@
 	unsigned short		no_ids;
 	unsigned short		s_major;
 	unsigned short		s_minor;
-	squashfs_inode_t	root_inode;
+	squashfs_inode		root_inode;
 	long long		bytes_used;
 	long long		id_table_start;
 	long long		xattr_id_table_start;
@@ -375,7 +390,7 @@
 	unsigned short		guid;
 	unsigned int		mtime;
 	unsigned int 		inode_number;
-	squashfs_block_t	start_block;
+	squashfs_block		start_block;
 	long long		file_size;
 	long long		sparse;
 	unsigned int		nlink;
diff -aurN squashfs4.1.old/squashfs-tools/squashfs_swap.h squashfs4.1.new/squashfs-tools/squashfs_swap.h
--- squashfs4.1.old/squashfs-tools/squashfs_swap.h	2010-09-16 03:28:57.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/squashfs_swap.h	2010-12-31 21:21:26.000000000 +0000
@@ -43,172 +43,172 @@
 extern void inswap_le64_num(long long *, int);
 
 #define _SQUASHFS_SWAP_SUPER_BLOCK(s, d, SWAP_FUNC) {\
-	SWAP_FUNC(32, s, d, s_magic, squashfs_super_block);\
-	SWAP_FUNC(32, s, d, inodes, squashfs_super_block);\
-	SWAP_FUNC(32, s, d, mkfs_time, squashfs_super_block);\
-	SWAP_FUNC(32, s, d, block_size, squashfs_super_block);\
-	SWAP_FUNC(32, s, d, fragments, squashfs_super_block);\
-	SWAP_FUNC(16, s, d, compression, squashfs_super_block);\
-	SWAP_FUNC(16, s, d, block_log, squashfs_super_block);\
-	SWAP_FUNC(16, s, d, flags, squashfs_super_block);\
-	SWAP_FUNC(16, s, d, no_ids, squashfs_super_block);\
-	SWAP_FUNC(16, s, d, s_major, squashfs_super_block);\
-	SWAP_FUNC(16, s, d, s_minor, squashfs_super_block);\
-	SWAP_FUNC(64, s, d, root_inode, squashfs_super_block);\
-	SWAP_FUNC(64, s, d, bytes_used, squashfs_super_block);\
-	SWAP_FUNC(64, s, d, id_table_start, squashfs_super_block);\
-	SWAP_FUNC(64, s, d, xattr_id_table_start, squashfs_super_block);\
-	SWAP_FUNC(64, s, d, inode_table_start, squashfs_super_block);\
-	SWAP_FUNC(64, s, d, directory_table_start, squashfs_super_block);\
-	SWAP_FUNC(64, s, d, fragment_table_start, squashfs_super_block);\
-	SWAP_FUNC(64, s, d, lookup_table_start, squashfs_super_block);\
+	SWAP_FUNC(32, s, d, s_magic, struct squashfs_super_block);\
+	SWAP_FUNC(32, s, d, inodes, struct squashfs_super_block);\
+	SWAP_FUNC(32, s, d, mkfs_time, struct squashfs_super_block);\
+	SWAP_FUNC(32, s, d, block_size, struct squashfs_super_block);\
+	SWAP_FUNC(32, s, d, fragments, struct squashfs_super_block);\
+	SWAP_FUNC(16, s, d, compression, struct squashfs_super_block);\
+	SWAP_FUNC(16, s, d, block_log, struct squashfs_super_block);\
+	SWAP_FUNC(16, s, d, flags, struct squashfs_super_block);\
+	SWAP_FUNC(16, s, d, no_ids, struct squashfs_super_block);\
+	SWAP_FUNC(16, s, d, s_major, struct squashfs_super_block);\
+	SWAP_FUNC(16, s, d, s_minor, struct squashfs_super_block);\
+	SWAP_FUNC(64, s, d, root_inode, struct squashfs_super_block);\
+	SWAP_FUNC(64, s, d, bytes_used, struct squashfs_super_block);\
+	SWAP_FUNC(64, s, d, id_table_start, struct squashfs_super_block);\
+	SWAP_FUNC(64, s, d, xattr_id_table_start, struct squashfs_super_block);\
+	SWAP_FUNC(64, s, d, inode_table_start, struct squashfs_super_block);\
+	SWAP_FUNC(64, s, d, directory_table_start, struct squashfs_super_block);\
+	SWAP_FUNC(64, s, d, fragment_table_start, struct squashfs_super_block);\
+	SWAP_FUNC(64, s, d, lookup_table_start, struct squashfs_super_block);\
 }
 
 #define _SQUASHFS_SWAP_DIR_INDEX(s, d, SWAP_FUNC) {\
-	SWAP_FUNC(32, s, d, index, squashfs_dir_index);\
-	SWAP_FUNC(32, s, d, start_block, squashfs_dir_index);\
-	SWAP_FUNC(32, s, d, size, squashfs_dir_index);\
+	SWAP_FUNC(32, s, d, index, struct squashfs_dir_index);\
+	SWAP_FUNC(32, s, d, start_block, struct squashfs_dir_index);\
+	SWAP_FUNC(32, s, d, size, struct squashfs_dir_index);\
 }
 
 #define _SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, SWAP_FUNC) {\
-	SWAP_FUNC(16, s, d, inode_type, squashfs_base_inode_header);\
-	SWAP_FUNC(16, s, d, mode, squashfs_base_inode_header);\
-	SWAP_FUNC(16, s, d, uid, squashfs_base_inode_header);\
-	SWAP_FUNC(16, s, d, guid, squashfs_base_inode_header);\
-	SWAP_FUNC(32, s, d, mtime, squashfs_base_inode_header);\
-	SWAP_FUNC(32, s, d, inode_number, squashfs_base_inode_header);\
+	SWAP_FUNC(16, s, d, inode_type, struct squashfs_base_inode_header);\
+	SWAP_FUNC(16, s, d, mode, struct squashfs_base_inode_header);\
+	SWAP_FUNC(16, s, d, uid, struct squashfs_base_inode_header);\
+	SWAP_FUNC(16, s, d, guid, struct squashfs_base_inode_header);\
+	SWAP_FUNC(32, s, d, mtime, struct squashfs_base_inode_header);\
+	SWAP_FUNC(32, s, d, inode_number, struct squashfs_base_inode_header);\
 }
 
 #define _SQUASHFS_SWAP_IPC_INODE_HEADER(s, d, SWAP_FUNC) {\
-	SWAP_FUNC(16, s, d, inode_type, squashfs_ipc_inode_header);\
-	SWAP_FUNC(16, s, d, mode, squashfs_ipc_inode_header);\
-	SWAP_FUNC(16, s, d, uid, squashfs_ipc_inode_header);\
-	SWAP_FUNC(16, s, d, guid, squashfs_ipc_inode_header);\
-	SWAP_FUNC(32, s, d, mtime, squashfs_ipc_inode_header);\
-	SWAP_FUNC(32, s, d, inode_number, squashfs_ipc_inode_header);\
-	SWAP_FUNC(32, s, d, nlink, squashfs_ipc_inode_header);\
+	SWAP_FUNC(16, s, d, inode_type, struct squashfs_ipc_inode_header);\
+	SWAP_FUNC(16, s, d, mode, struct squashfs_ipc_inode_header);\
+	SWAP_FUNC(16, s, d, uid, struct squashfs_ipc_inode_header);\
+	SWAP_FUNC(16, s, d, guid, struct squashfs_ipc_inode_header);\
+	SWAP_FUNC(32, s, d, mtime, struct squashfs_ipc_inode_header);\
+	SWAP_FUNC(32, s, d, inode_number, struct squashfs_ipc_inode_header);\
+	SWAP_FUNC(32, s, d, nlink, struct squashfs_ipc_inode_header);\
 }
 
 #define _SQUASHFS_SWAP_LIPC_INODE_HEADER(s, d, SWAP_FUNC) {\
-	SWAP_FUNC(16, s, d, inode_type, squashfs_lipc_inode_header);\
-	SWAP_FUNC(16, s, d, mode, squashfs_lipc_inode_header);\
-	SWAP_FUNC(16, s, d, uid, squashfs_lipc_inode_header);\
-	SWAP_FUNC(16, s, d, guid, squashfs_lipc_inode_header);\
-	SWAP_FUNC(32, s, d, mtime, squashfs_lipc_inode_header);\
-	SWAP_FUNC(32, s, d, inode_number, squashfs_lipc_inode_header);\
-	SWAP_FUNC(32, s, d, nlink, squashfs_lipc_inode_header);\
-	SWAP_FUNC(32, s, d, xattr, squashfs_lipc_inode_header);\
+	SWAP_FUNC(16, s, d, inode_type, struct squashfs_lipc_inode_header);\
+	SWAP_FUNC(16, s, d, mode, struct squashfs_lipc_inode_header);\
+	SWAP_FUNC(16, s, d, uid, struct squashfs_lipc_inode_header);\
+	SWAP_FUNC(16, s, d, guid, struct squashfs_lipc_inode_header);\
+	SWAP_FUNC(32, s, d, mtime, struct squashfs_lipc_inode_header);\
+	SWAP_FUNC(32, s, d, inode_number, struct squashfs_lipc_inode_header);\
+	SWAP_FUNC(32, s, d, nlink, struct squashfs_lipc_inode_header);\
+	SWAP_FUNC(32, s, d, xattr, struct squashfs_lipc_inode_header);\
 }
 
 #define _SQUASHFS_SWAP_DEV_INODE_HEADER(s, d, SWAP_FUNC) {\
-	SWAP_FUNC(16, s, d, inode_type, squashfs_dev_inode_header);\
-	SWAP_FUNC(16, s, d, mode, squashfs_dev_inode_header);\
-	SWAP_FUNC(16, s, d, uid, squashfs_dev_inode_header);\
-	SWAP_FUNC(16, s, d, guid, squashfs_dev_inode_header);\
-	SWAP_FUNC(32, s, d, mtime, squashfs_dev_inode_header);\
-	SWAP_FUNC(32, s, d, inode_number, squashfs_dev_inode_header);\
-	SWAP_FUNC(32, s, d, nlink, squashfs_dev_inode_header);\
-	SWAP_FUNC(32, s, d, rdev, squashfs_dev_inode_header);\
+	SWAP_FUNC(16, s, d, inode_type, struct squashfs_dev_inode_header);\
+	SWAP_FUNC(16, s, d, mode, struct squashfs_dev_inode_header);\
+	SWAP_FUNC(16, s, d, uid, struct squashfs_dev_inode_header);\
+	SWAP_FUNC(16, s, d, guid, struct squashfs_dev_inode_header);\
+	SWAP_FUNC(32, s, d, mtime, struct squashfs_dev_inode_header);\
+	SWAP_FUNC(32, s, d, inode_number, struct squashfs_dev_inode_header);\
+	SWAP_FUNC(32, s, d, nlink, struct squashfs_dev_inode_header);\
+	SWAP_FUNC(32, s, d, rdev, struct squashfs_dev_inode_header);\
 }
 
 #define _SQUASHFS_SWAP_LDEV_INODE_HEADER(s, d, SWAP_FUNC) {\
-	SWAP_FUNC(16, s, d, inode_type, squashfs_ldev_inode_header);\
-	SWAP_FUNC(16, s, d, mode, squashfs_ldev_inode_header);\
-	SWAP_FUNC(16, s, d, uid, squashfs_ldev_inode_header);\
-	SWAP_FUNC(16, s, d, guid, squashfs_ldev_inode_header);\
-	SWAP_FUNC(32, s, d, mtime, squashfs_ldev_inode_header);\
-	SWAP_FUNC(32, s, d, inode_number, squashfs_ldev_inode_header);\
-	SWAP_FUNC(32, s, d, nlink, squashfs_ldev_inode_header);\
-	SWAP_FUNC(32, s, d, rdev, squashfs_ldev_inode_header);\
-	SWAP_FUNC(32, s, d, xattr, squashfs_ldev_inode_header);\
+	SWAP_FUNC(16, s, d, inode_type, struct squashfs_ldev_inode_header);\
+	SWAP_FUNC(16, s, d, mode, struct squashfs_ldev_inode_header);\
+	SWAP_FUNC(16, s, d, uid, struct squashfs_ldev_inode_header);\
+	SWAP_FUNC(16, s, d, guid, struct squashfs_ldev_inode_header);\
+	SWAP_FUNC(32, s, d, mtime, struct squashfs_ldev_inode_header);\
+	SWAP_FUNC(32, s, d, inode_number, struct squashfs_ldev_inode_header);\
+	SWAP_FUNC(32, s, d, nlink, struct squashfs_ldev_inode_header);\
+	SWAP_FUNC(32, s, d, rdev, struct squashfs_ldev_inode_header);\
+	SWAP_FUNC(32, s, d, xattr, struct squashfs_ldev_inode_header);\
 }
 
 #define _SQUASHFS_SWAP_SYMLINK_INODE_HEADER(s, d, SWAP_FUNC) {\
-	SWAP_FUNC(16, s, d, inode_type, squashfs_symlink_inode_header);\
-	SWAP_FUNC(16, s, d, mode, squashfs_symlink_inode_header);\
-	SWAP_FUNC(16, s, d, uid, squashfs_symlink_inode_header);\
-	SWAP_FUNC(16, s, d, guid, squashfs_symlink_inode_header);\
-	SWAP_FUNC(32, s, d, mtime, squashfs_symlink_inode_header);\
-	SWAP_FUNC(32, s, d, inode_number, squashfs_symlink_inode_header);\
-	SWAP_FUNC(32, s, d, nlink, squashfs_symlink_inode_header);\
-	SWAP_FUNC(32, s, d, symlink_size, squashfs_symlink_inode_header);\
+	SWAP_FUNC(16, s, d, inode_type, struct squashfs_symlink_inode_header);\
+	SWAP_FUNC(16, s, d, mode, struct squashfs_symlink_inode_header);\
+	SWAP_FUNC(16, s, d, uid, struct squashfs_symlink_inode_header);\
+	SWAP_FUNC(16, s, d, guid, struct squashfs_symlink_inode_header);\
+	SWAP_FUNC(32, s, d, mtime, struct squashfs_symlink_inode_header);\
+	SWAP_FUNC(32, s, d, inode_number, struct squashfs_symlink_inode_header);\
+	SWAP_FUNC(32, s, d, nlink, struct squashfs_symlink_inode_header);\
+	SWAP_FUNC(32, s, d, symlink_size, struct squashfs_symlink_inode_header);\
 }
 
 #define _SQUASHFS_SWAP_REG_INODE_HEADER(s, d, SWAP_FUNC) {\
-	SWAP_FUNC(16, s, d, inode_type, squashfs_reg_inode_header);\
-	SWAP_FUNC(16, s, d, mode, squashfs_reg_inode_header);\
-	SWAP_FUNC(16, s, d, uid, squashfs_reg_inode_header);\
-	SWAP_FUNC(16, s, d, guid, squashfs_reg_inode_header);\
-	SWAP_FUNC(32, s, d, mtime, squashfs_reg_inode_header);\
-	SWAP_FUNC(32, s, d, inode_number, squashfs_reg_inode_header);\
-	SWAP_FUNC(32, s, d, start_block, squashfs_reg_inode_header);\
-	SWAP_FUNC(32, s, d, fragment, squashfs_reg_inode_header);\
-	SWAP_FUNC(32, s, d, offset, squashfs_reg_inode_header);\
-	SWAP_FUNC(32, s, d, file_size, squashfs_reg_inode_header);\
+	SWAP_FUNC(16, s, d, inode_type, struct squashfs_reg_inode_header);\
+	SWAP_FUNC(16, s, d, mode, struct squashfs_reg_inode_header);\
+	SWAP_FUNC(16, s, d, uid, struct squashfs_reg_inode_header);\
+	SWAP_FUNC(16, s, d, guid, struct squashfs_reg_inode_header);\
+	SWAP_FUNC(32, s, d, mtime, struct squashfs_reg_inode_header);\
+	SWAP_FUNC(32, s, d, inode_number, struct squashfs_reg_inode_header);\
+	SWAP_FUNC(32, s, d, start_block, struct squashfs_reg_inode_header);\
+	SWAP_FUNC(32, s, d, fragment, struct squashfs_reg_inode_header);\
+	SWAP_FUNC(32, s, d, offset, struct squashfs_reg_inode_header);\
+	SWAP_FUNC(32, s, d, file_size, struct squashfs_reg_inode_header);\
 }
 
 #define _SQUASHFS_SWAP_LREG_INODE_HEADER(s, d, SWAP_FUNC) {\
-	SWAP_FUNC(16, s, d, inode_type, squashfs_lreg_inode_header);\
-	SWAP_FUNC(16, s, d, mode, squashfs_lreg_inode_header);\
-	SWAP_FUNC(16, s, d, uid, squashfs_lreg_inode_header);\
-	SWAP_FUNC(16, s, d, guid, squashfs_lreg_inode_header);\
-	SWAP_FUNC(32, s, d, mtime, squashfs_lreg_inode_header);\
-	SWAP_FUNC(32, s, d, inode_number, squashfs_lreg_inode_header);\
-	SWAP_FUNC(64, s, d, start_block, squashfs_lreg_inode_header);\
-	SWAP_FUNC(64, s, d, file_size, squashfs_lreg_inode_header);\
-	SWAP_FUNC(64, s, d, sparse, squashfs_lreg_inode_header);\
-	SWAP_FUNC(32, s, d, nlink, squashfs_lreg_inode_header);\
-	SWAP_FUNC(32, s, d, fragment, squashfs_lreg_inode_header);\
-	SWAP_FUNC(32, s, d, offset, squashfs_lreg_inode_header);\
-	SWAP_FUNC(32, s, d, xattr, squashfs_lreg_inode_header);\
+	SWAP_FUNC(16, s, d, inode_type, struct squashfs_lreg_inode_header);\
+	SWAP_FUNC(16, s, d, mode, struct squashfs_lreg_inode_header);\
+	SWAP_FUNC(16, s, d, uid, struct squashfs_lreg_inode_header);\
+	SWAP_FUNC(16, s, d, guid, struct squashfs_lreg_inode_header);\
+	SWAP_FUNC(32, s, d, mtime, struct squashfs_lreg_inode_header);\
+	SWAP_FUNC(32, s, d, inode_number, struct squashfs_lreg_inode_header);\
+	SWAP_FUNC(64, s, d, start_block, struct squashfs_lreg_inode_header);\
+	SWAP_FUNC(64, s, d, file_size, struct squashfs_lreg_inode_header);\
+	SWAP_FUNC(64, s, d, sparse, struct squashfs_lreg_inode_header);\
+	SWAP_FUNC(32, s, d, nlink, struct squashfs_lreg_inode_header);\
+	SWAP_FUNC(32, s, d, fragment, struct squashfs_lreg_inode_header);\
+	SWAP_FUNC(32, s, d, offset, struct squashfs_lreg_inode_header);\
+	SWAP_FUNC(32, s, d, xattr, struct squashfs_lreg_inode_header);\
 }
 
 #define _SQUASHFS_SWAP_DIR_INODE_HEADER(s, d, SWAP_FUNC) {\
-	SWAP_FUNC(16, s, d, inode_type, squashfs_dir_inode_header);\
-	SWAP_FUNC(16, s, d, mode, squashfs_dir_inode_header);\
-	SWAP_FUNC(16, s, d, uid, squashfs_dir_inode_header);\
-	SWAP_FUNC(16, s, d, guid, squashfs_dir_inode_header);\
-	SWAP_FUNC(32, s, d, mtime, squashfs_dir_inode_header);\
-	SWAP_FUNC(32, s, d, inode_number, squashfs_dir_inode_header);\
-	SWAP_FUNC(32, s, d, start_block, squashfs_dir_inode_header);\
-	SWAP_FUNC(32, s, d, nlink, squashfs_dir_inode_header);\
-	SWAP_FUNC(16, s, d, file_size, squashfs_dir_inode_header);\
-	SWAP_FUNC(16, s, d, offset, squashfs_dir_inode_header);\
-	SWAP_FUNC(32, s, d, parent_inode, squashfs_dir_inode_header);\
+	SWAP_FUNC(16, s, d, inode_type, struct squashfs_dir_inode_header);\
+	SWAP_FUNC(16, s, d, mode, struct squashfs_dir_inode_header);\
+	SWAP_FUNC(16, s, d, uid, struct squashfs_dir_inode_header);\
+	SWAP_FUNC(16, s, d, guid, struct squashfs_dir_inode_header);\
+	SWAP_FUNC(32, s, d, mtime, struct squashfs_dir_inode_header);\
+	SWAP_FUNC(32, s, d, inode_number, struct squashfs_dir_inode_header);\
+	SWAP_FUNC(32, s, d, start_block, struct squashfs_dir_inode_header);\
+	SWAP_FUNC(32, s, d, nlink, struct squashfs_dir_inode_header);\
+	SWAP_FUNC(16, s, d, file_size, struct squashfs_dir_inode_header);\
+	SWAP_FUNC(16, s, d, offset, struct squashfs_dir_inode_header);\
+	SWAP_FUNC(32, s, d, parent_inode, struct squashfs_dir_inode_header);\
 }
 
 #define _SQUASHFS_SWAP_LDIR_INODE_HEADER(s, d, SWAP_FUNC) {\
-	SWAP_FUNC(16, s, d, inode_type, squashfs_ldir_inode_header);\
-	SWAP_FUNC(16, s, d, mode, squashfs_ldir_inode_header);\
-	SWAP_FUNC(16, s, d, uid, squashfs_ldir_inode_header);\
-	SWAP_FUNC(16, s, d, guid, squashfs_ldir_inode_header);\
-	SWAP_FUNC(32, s, d, mtime, squashfs_ldir_inode_header);\
-	SWAP_FUNC(32, s, d, inode_number, squashfs_ldir_inode_header);\
-	SWAP_FUNC(32, s, d, nlink, squashfs_ldir_inode_header);\
-	SWAP_FUNC(32, s, d, file_size, squashfs_ldir_inode_header);\
-	SWAP_FUNC(32, s, d, start_block, squashfs_ldir_inode_header);\
-	SWAP_FUNC(32, s, d, parent_inode, squashfs_ldir_inode_header);\
-	SWAP_FUNC(16, s, d, i_count, squashfs_ldir_inode_header);\
-	SWAP_FUNC(16, s, d, offset, squashfs_ldir_inode_header);\
-	SWAP_FUNC(32, s, d, xattr, squashfs_ldir_inode_header);\
+	SWAP_FUNC(16, s, d, inode_type, struct squashfs_ldir_inode_header);\
+	SWAP_FUNC(16, s, d, mode, struct squashfs_ldir_inode_header);\
+	SWAP_FUNC(16, s, d, uid, struct squashfs_ldir_inode_header);\
+	SWAP_FUNC(16, s, d, guid, struct squashfs_ldir_inode_header);\
+	SWAP_FUNC(32, s, d, mtime, struct squashfs_ldir_inode_header);\
+	SWAP_FUNC(32, s, d, inode_number, struct squashfs_ldir_inode_header);\
+	SWAP_FUNC(32, s, d, nlink, struct squashfs_ldir_inode_header);\
+	SWAP_FUNC(32, s, d, file_size, struct squashfs_ldir_inode_header);\
+	SWAP_FUNC(32, s, d, start_block, struct squashfs_ldir_inode_header);\
+	SWAP_FUNC(32, s, d, parent_inode, struct squashfs_ldir_inode_header);\
+	SWAP_FUNC(16, s, d, i_count, struct squashfs_ldir_inode_header);\
+	SWAP_FUNC(16, s, d, offset, struct squashfs_ldir_inode_header);\
+	SWAP_FUNC(32, s, d, xattr, struct squashfs_ldir_inode_header);\
 }
 
 #define _SQUASHFS_SWAP_DIR_ENTRY(s, d, SWAP_FUNC) {\
-	SWAP_FUNC(16, s, d, offset, squashfs_dir_entry);\
-	SWAP_FUNC##S(16, s, d, inode_number, squashfs_dir_entry);\
-	SWAP_FUNC(16, s, d, type, squashfs_dir_entry);\
-	SWAP_FUNC(16, s, d, size, squashfs_dir_entry);\
+	SWAP_FUNC(16, s, d, offset, struct squashfs_dir_entry);\
+	SWAP_FUNC##S(16, s, d, inode_number, struct squashfs_dir_entry);\
+	SWAP_FUNC(16, s, d, type, struct squashfs_dir_entry);\
+	SWAP_FUNC(16, s, d, size, struct squashfs_dir_entry);\
 }
 
 #define _SQUASHFS_SWAP_DIR_HEADER(s, d, SWAP_FUNC) {\
-	SWAP_FUNC(32, s, d, count, squashfs_dir_header);\
-	SWAP_FUNC(32, s, d, start_block, squashfs_dir_header);\
-	SWAP_FUNC(32, s, d, inode_number, squashfs_dir_header);\
+	SWAP_FUNC(32, s, d, count, struct squashfs_dir_header);\
+	SWAP_FUNC(32, s, d, start_block, struct squashfs_dir_header);\
+	SWAP_FUNC(32, s, d, inode_number, struct squashfs_dir_header);\
 }
 
 #define _SQUASHFS_SWAP_FRAGMENT_ENTRY(s, d, SWAP_FUNC) {\
-	SWAP_FUNC(64, s, d, start_block, squashfs_fragment_entry);\
-	SWAP_FUNC(32, s, d, size, squashfs_fragment_entry);\
+	SWAP_FUNC(64, s, d, start_block, struct squashfs_fragment_entry);\
+	SWAP_FUNC(32, s, d, size, struct squashfs_fragment_entry);\
 }
 
 #define _SQUASHFS_SWAP_XATTR_ENTRY(s, d, SWAP_FUNC) {\
diff -aurN squashfs4.1.old/squashfs-tools/unsquash-1.c squashfs4.1.new/squashfs-tools/unsquash-1.c
--- squashfs4.1.old/squashfs-tools/unsquash-1.c	2010-08-25 18:25:33.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/unsquash-1.c	2010-12-31 10:06:51.000000000 +0000
@@ -55,7 +55,7 @@
 
 struct inode *read_inode_1(unsigned int start_block, unsigned int offset)
 {
-	static squashfs_inode_header_1 header;
+	static union squashfs_inode_header_1 header;
 	long long start = sBlk.s.inode_table_start + start_block;
 	int bytes = lookup_entry(inode_table_hash, start);
 	char *block_ptr = inode_table + bytes + offset;
@@ -138,7 +138,7 @@
 
 			i.data = inode->file_size;
 			i.time = inode->mtime;
-			i.blocks = (inode->file_size + sBlk.s.block_size - 1) >>
+			i.blocks = (i.data + sBlk.s.block_size - 1) >>
 				sBlk.s.block_log;
 			i.start = inode->start_block;
 			i.block_ptr = block_ptr + sizeof(*inode);
@@ -226,7 +226,8 @@
 	bytes += (*i)->offset;
 	size = (*i)->data + bytes;
 
-	if((dir = malloc(sizeof(struct dir))) == NULL)
+	dir = malloc(sizeof(struct dir));
+	if(dir == NULL)
 		EXIT_UNSQUASH("squashfs_opendir: malloc failed!\n");
 
 	dir->dir_count = 0;
diff -aurN squashfs4.1.old/squashfs-tools/unsquash-2.c squashfs4.1.new/squashfs-tools/unsquash-2.c
--- squashfs4.1.old/squashfs-tools/unsquash-2.c	2010-08-25 18:26:08.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/unsquash-2.c	2010-12-31 10:08:57.000000000 +0000
@@ -121,7 +121,7 @@
 
 struct inode *read_inode_2(unsigned int start_block, unsigned int offset)
 {
-	static squashfs_inode_header_2 header;
+	static union squashfs_inode_header_2 header;
 	long long start = sBlk.s.inode_table_start + start_block;
 	int bytes = lookup_entry(inode_table_hash, start);
 	char *block_ptr = inode_table + bytes + offset;
@@ -205,8 +205,8 @@
 			i.fragment = inode->fragment;
 			i.offset = inode->offset;
 			i.blocks = inode->fragment == SQUASHFS_INVALID_FRAG ?
-				(inode->file_size + sBlk.s.block_size - 1) >>
-				sBlk.s.block_log : inode->file_size >>
+				(i.data + sBlk.s.block_size - 1) >>
+				sBlk.s.block_log : i.data >>
 				sBlk.s.block_log;
 			i.start = inode->start_block;
 			i.sparse = 0;
diff -aurN squashfs4.1.old/squashfs-tools/unsquash-3.c squashfs4.1.new/squashfs-tools/unsquash-3.c
--- squashfs4.1.old/squashfs-tools/unsquash-3.c	2010-08-25 18:26:23.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/unsquash-3.c	2010-12-31 10:28:39.000000000 +0000
@@ -30,7 +30,7 @@
 int read_fragment_table_3()
 {
 	int res, i, indexes = SQUASHFS_FRAGMENT_INDEXES_3(sBlk.s.fragments);
-	squashfs_fragment_index fragment_table_index[indexes];
+	long long fragment_table_index[indexes];
 
 	TRACE("read_fragment_table: %d fragments, reading %d fragment indexes "
 		"from 0x%llx\n", sBlk.s.fragments, indexes,
@@ -39,13 +39,14 @@
 	if(sBlk.s.fragments == 0)
 		return TRUE;
 
-	if((fragment_table = malloc(sBlk.s.fragments *
-			sizeof(squashfs_fragment_entry_3))) == NULL)
+	fragment_table = malloc(sBlk.s.fragments *
+		sizeof(squashfs_fragment_entry_3));
+	if(fragment_table == NULL)
 		EXIT_UNSQUASH("read_fragment_table: failed to allocate "
 			"fragment table\n");
 
 	if(swap) {
-		squashfs_fragment_index sfragment_table_index[indexes];
+		long long sfragment_table_index[indexes];
 
 		res = read_fs_bytes(fd, sBlk.s.fragment_table_start,
 			SQUASHFS_FRAGMENT_INDEX_BYTES_3(sBlk.s.fragments),
@@ -107,7 +108,7 @@
 
 struct inode *read_inode_3(unsigned int start_block, unsigned int offset)
 {
-	static squashfs_inode_header_3 header;
+	static union squashfs_inode_header_3 header;
 	long long start = sBlk.s.inode_table_start + start_block;
 	int bytes = lookup_entry(inode_table_hash, start);
 	char *block_ptr = inode_table + bytes + offset;
@@ -188,9 +189,9 @@
 			i.fragment = inode->fragment;
 			i.offset = inode->offset;
 			i.blocks = inode->fragment == SQUASHFS_INVALID_FRAG ?
-				(inode->file_size + sBlk.s.block_size - 1) >>
+				(i.data + sBlk.s.block_size - 1) >>
 				sBlk.s.block_log :
-				inode->file_size >> sBlk.s.block_log;
+				i.data >> sBlk.s.block_log;
 			i.start = inode->start_block;
 			i.sparse = 1;
 			i.block_ptr = block_ptr + sizeof(*inode);
@@ -298,7 +299,8 @@
 	bytes += (*i)->offset;
 	size = (*i)->data + bytes - 3;
 
-	if((dir = malloc(sizeof(struct dir))) == NULL)
+	dir = malloc(sizeof(struct dir));
+	if(dir == NULL)
 		EXIT_UNSQUASH("squashfs_opendir: malloc failed!\n");
 
 	dir->dir_count = 0;
diff -aurN squashfs4.1.old/squashfs-tools/unsquash-4.c squashfs4.1.new/squashfs-tools/unsquash-4.c
--- squashfs4.1.old/squashfs-tools/unsquash-4.c	2010-08-25 18:26:33.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/unsquash-4.c	2010-12-31 20:55:43.000000000 +0000
@@ -32,7 +32,7 @@
 int read_fragment_table_4()
 {
 	int res, i, indexes = SQUASHFS_FRAGMENT_INDEXES(sBlk.s.fragments);
-	squashfs_fragment_index fragment_table_index[indexes];
+	long long fragment_table_index[indexes];
 
 	TRACE("read_fragment_table: %d fragments, reading %d fragment indexes "
 		"from 0x%llx\n", sBlk.s.fragments, indexes,
@@ -41,8 +41,9 @@
 	if(sBlk.s.fragments == 0)
 		return TRUE;
 
-	if((fragment_table = malloc(sBlk.s.fragments *
-			sizeof(squashfs_fragment_entry))) == NULL)
+	fragment_table = malloc(sBlk.s.fragments *
+		sizeof(struct squashfs_fragment_entry));
+	if(fragment_table == NULL)
 		EXIT_UNSQUASH("read_fragment_table: failed to allocate "
 			"fragment table\n");
 
@@ -80,7 +81,9 @@
 {
 	TRACE("read_fragment: reading fragment %d\n", fragment);
 
-	squashfs_fragment_entry *fragment_entry = &fragment_table[fragment];
+	struct squashfs_fragment_entry *fragment_entry;
+
+	fragment_entry = &fragment_table[fragment];
 	*start_block = fragment_entry->start_block;
 	*size = fragment_entry->size;
 }
@@ -88,7 +91,7 @@
 
 struct inode *read_inode_4(unsigned int start_block, unsigned int offset)
 {
-	static squashfs_inode_header header;
+	static union squashfs_inode_header header;
 	long long start = sBlk.s.inode_table_start + start_block;
 	int bytes = lookup_entry(inode_table_hash, start);
 	char *block_ptr = inode_table + bytes + offset;
@@ -111,7 +114,7 @@
 
 	switch(header.base.inode_type) {
 		case SQUASHFS_DIR_TYPE: {
-			squashfs_dir_inode_header *inode = &header.dir;
+			struct squashfs_dir_inode_header *inode = &header.dir;
 
 			SQUASHFS_SWAP_DIR_INODE_HEADER(inode, block_ptr);
 
@@ -122,7 +125,7 @@
 			break;
 		}
 		case SQUASHFS_LDIR_TYPE: {
-			squashfs_ldir_inode_header *inode = &header.ldir;
+			struct squashfs_ldir_inode_header *inode = &header.ldir;
 
 			SQUASHFS_SWAP_LDIR_INODE_HEADER(inode, block_ptr);
 
@@ -133,7 +136,7 @@
 			break;
 		}
 		case SQUASHFS_FILE_TYPE: {
-			squashfs_reg_inode_header *inode = &header.reg;
+			struct squashfs_reg_inode_header *inode = &header.reg;
 
 			SQUASHFS_SWAP_REG_INODE_HEADER(inode, block_ptr);
 
@@ -143,9 +146,9 @@
 			i.fragment = inode->fragment;
 			i.offset = inode->offset;
 			i.blocks = inode->fragment == SQUASHFS_INVALID_FRAG ?
-				(inode->file_size + sBlk.s.block_size - 1) >>
+				(i.data + sBlk.s.block_size - 1) >>
 				sBlk.s.block_log :
-				inode->file_size >> sBlk.s.block_log;
+				i.data >> sBlk.s.block_log;
 			i.start = inode->start_block;
 			i.sparse = 0;
 			i.block_ptr = block_ptr + sizeof(*inode);
@@ -153,7 +156,7 @@
 			break;
 		}	
 		case SQUASHFS_LREG_TYPE: {
-			squashfs_lreg_inode_header *inode = &header.lreg;
+			struct squashfs_lreg_inode_header *inode = &header.lreg;
 
 			SQUASHFS_SWAP_LREG_INODE_HEADER(inode, block_ptr);
 
@@ -174,7 +177,7 @@
 		}	
 		case SQUASHFS_SYMLINK_TYPE:
 		case SQUASHFS_LSYMLINK_TYPE: {
-			squashfs_symlink_inode_header *inode = &header.symlink;
+			struct squashfs_symlink_inode_header *inode = &header.symlink;
 
 			SQUASHFS_SWAP_SYMLINK_INODE_HEADER(inode, block_ptr);
 
@@ -183,14 +186,14 @@
 				EXIT_UNSQUASH("read_inode: failed to malloc "
 					"symlink data\n");
 			strncpy(i.symlink, block_ptr +
-				sizeof(squashfs_symlink_inode_header),
+				sizeof(struct squashfs_symlink_inode_header),
 				inode->symlink_size);
 			i.symlink[inode->symlink_size] = '\0';
 			i.data = inode->symlink_size;
 
 			if(header.base.inode_type == SQUASHFS_LSYMLINK_TYPE)
 				SQUASHFS_SWAP_INTS(&i.xattr, block_ptr +
-					sizeof(squashfs_symlink_inode_header) +
+					sizeof(struct squashfs_symlink_inode_header) +
 					inode->symlink_size, 1);
 			else
 				i.xattr = SQUASHFS_INVALID_XATTR;
@@ -198,7 +201,7 @@
 		}
  		case SQUASHFS_BLKDEV_TYPE:
 	 	case SQUASHFS_CHRDEV_TYPE: {
-			squashfs_dev_inode_header *inode = &header.dev;
+			struct squashfs_dev_inode_header *inode = &header.dev;
 
 			SQUASHFS_SWAP_DEV_INODE_HEADER(inode, block_ptr);
 
@@ -208,7 +211,7 @@
 		}
  		case SQUASHFS_LBLKDEV_TYPE:
 	 	case SQUASHFS_LCHRDEV_TYPE: {
-			squashfs_ldev_inode_header *inode = &header.ldev;
+			struct squashfs_ldev_inode_header *inode = &header.ldev;
 
 			SQUASHFS_SWAP_LDEV_INODE_HEADER(inode, block_ptr);
 
@@ -223,7 +226,7 @@
 			break;
 		case SQUASHFS_LFIFO_TYPE:
 		case SQUASHFS_LSOCKET_TYPE: {
-			squashfs_lipc_inode_header *inode = &header.lipc;
+			struct squashfs_lipc_inode_header *inode = &header.lipc;
 
 			SQUASHFS_SWAP_LIPC_INODE_HEADER(inode, block_ptr);
 
@@ -242,10 +245,10 @@
 struct dir *squashfs_opendir_4(unsigned int block_start, unsigned int offset,
 	struct inode **i)
 {
-	squashfs_dir_header dirh;
-	char buffer[sizeof(squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]
+	struct squashfs_dir_header dirh;
+	char buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]
 		__attribute__((aligned));
-	squashfs_dir_entry *dire = (squashfs_dir_entry *) buffer;
+	struct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;
 	long long start;
 	int bytes;
 	int dir_count, size;
@@ -266,7 +269,8 @@
 	bytes += (*i)->offset;
 	size = (*i)->data + bytes - 3;
 
-	if((dir = malloc(sizeof(struct dir))) == NULL)
+	dir = malloc(sizeof(struct dir));
+	if(dir == NULL)
 		EXIT_UNSQUASH("squashfs_opendir: malloc failed!\n");
 
 	dir->dir_count = 0;
diff -aurN squashfs4.1.old/squashfs-tools/unsquashfs.c squashfs4.1.new/squashfs-tools/unsquashfs.c
--- squashfs4.1.old/squashfs-tools/unsquashfs.c	2010-09-19 21:44:38.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/unsquashfs.c	2010-12-31 21:41:45.000000000 +0000
@@ -143,7 +143,8 @@
 	if(queue == NULL)
 		EXIT_UNSQUASH("Out of memory in queue_init\n");
 
-	if((queue->data = malloc(sizeof(void *) * (size + 1))) == NULL)
+	queue->data = malloc(sizeof(void *) * (size + 1));
+	if(queue->data == NULL)
 		EXIT_UNSQUASH("Out of memory in queue_init\n");
 
 	queue->size = size + 1;
@@ -453,13 +454,15 @@
 		return 1;
 	}
 
-	if((user = getpwuid(inode->uid)) == NULL) {
+	user = getpwuid(inode->uid);
+	if(user == NULL) {
 		sprintf(dummy, "%d", inode->uid);
 		userstr = dummy;
 	} else
 		userstr = user->pw_name;
 		 
-	if((group = getgrgid(inode->gid)) == NULL) {
+	group = getgrgid(inode->gid);
+	if(group == NULL) {
 		sprintf(dummy2, "%d", inode->gid);
 		groupstr = dummy2;
 	} else
@@ -508,7 +511,8 @@
 	int hash = CALCULATE_HASH(start);
 	struct hash_table_entry *hash_table_entry;
 
-	if((hash_table_entry = malloc(sizeof(struct hash_table_entry))) == NULL)
+	hash_table_entry = malloc(sizeof(struct hash_table_entry));
+	if(hash_table_entry == NULL)
 		EXIT_UNSQUASH("Out of memory in add_entry\n");
 
 	hash_table_entry->start = start;
@@ -593,7 +597,7 @@
 		if(read_fs_bytes(fd, start + offset, c_byte, buffer) == FALSE)
 			goto failed;
 
-		res = comp->uncompress(block, buffer, c_byte,
+		res = compressor_uncompress(comp, block, buffer, c_byte,
 			SQUASHFS_METADATA_SIZE, &error);
 
 		if(res == -1) {
@@ -632,7 +636,8 @@
 		if(read_fs_bytes(fd, start, c_byte, data) == FALSE)
 			goto failed;
 
-		res = comp->uncompress(block, data, c_byte, block_size, &error);
+		res = compressor_uncompress(comp, block, data, c_byte,
+			block_size, &error);
 
 		if(res == -1) {
 			ERROR("%s uncompress failed with error code %d\n",
@@ -737,7 +742,7 @@
 int lseek_broken = FALSE;
 char *zero_data = NULL;
 
-int write_block(int file_fd, char *buffer, int size, int hole, int sparse)
+int write_block(int file_fd, char *buffer, int size, long long hole, int sparse)
 {
 	off_t off = hole;
 
@@ -797,12 +802,14 @@
 		return FALSE;
 	}
 
-	if((block_list = malloc(inode->blocks * sizeof(unsigned int))) == NULL)
+	block_list = malloc(inode->blocks * sizeof(unsigned int));
+	if(block_list == NULL)
 		EXIT_UNSQUASH("write_file: unable to malloc block list\n");
 
 	s_ops.read_block_list(block_list, inode->block_ptr, inode->blocks);
 
-	if((file = malloc(sizeof(struct squashfs_file))) == NULL)
+	file = malloc(sizeof(struct squashfs_file));
+	if(file == NULL)
 		EXIT_UNSQUASH("write_file: unable to malloc file\n");
 
 	/*
@@ -1069,7 +1076,8 @@
 	target = get_component(target, targname);
 
 	if(paths == NULL) {
-		if((paths = malloc(sizeof(struct pathname))) == NULL)
+		paths = malloc(sizeof(struct pathname));
+		if(paths == NULL)
 			EXIT_UNSQUASH("failed to allocate paths\n");
 
 		paths->names = 0;
@@ -1299,9 +1307,12 @@
 		print_filename(parent_name, i);
 
 	if(!lsonly && mkdir(parent_name, (mode_t) dir->mode) == -1 &&
-			(!force || errno != EEXIST))
-		ERROR("dir_scan: failed to open directory %s, because %s\n",
+			(!force || errno != EEXIST)) {
+		ERROR("dir_scan: failed to make directory %s, because %s\n",
 			parent_name, strerror(errno));
+		squashfs_closedir(dir);
+		return;
+	}
 
 	while(squashfs_readdir(dir, &name, &start_block, &offset, &type)) {
 		TRACE("dir_scan: name %s, start_block %d, offset %d, type %d\n",
@@ -1357,43 +1368,62 @@
 		sBlk.s.s_major == 4 ? "" : swap ? "big endian " :
 		"little endian ", sBlk.s.s_major, sBlk.s.s_minor, source);
 #endif
+
 	printf("Creation or last append time %s", mkfs_str ? mkfs_str :
 		"failed to get time\n");
 	printf("Filesystem size %.2f Kbytes (%.2f Mbytes)\n",
 		sBlk.s.bytes_used / 1024.0, sBlk.s.bytes_used /
 		(1024.0 * 1024.0));
+
 	if(sBlk.s.s_major == 4)
 		printf("Compression %s\n", comp->name);
+
 	printf("Block size %d\n", sBlk.s.block_size);
 	printf("Filesystem is %sexportable via NFS\n",
 		SQUASHFS_EXPORTABLE(sBlk.s.flags) ? "" : "not ");
-
 	printf("Inodes are %scompressed\n",
 		SQUASHFS_UNCOMPRESSED_INODES(sBlk.s.flags) ? "un" : "");
 	printf("Data is %scompressed\n",
 		SQUASHFS_UNCOMPRESSED_DATA(sBlk.s.flags) ? "un" : "");
-	if(sBlk.s.s_major > 1 && !SQUASHFS_NO_FRAGMENTS(sBlk.s.flags))
-		printf("Fragments are %scompressed\n",
-			SQUASHFS_UNCOMPRESSED_FRAGMENTS(sBlk.s.flags) ? "un" :
-			"");
-	printf("Check data is %spresent in the filesystem\n",
-		SQUASHFS_CHECK_DATA(sBlk.s.flags) ? "" : "not ");
+
 	if(sBlk.s.s_major > 1) {
-		printf("Fragments are %spresent in the filesystem\n",
-			SQUASHFS_NO_FRAGMENTS(sBlk.s.flags) ? "not " : "");
-		printf("Always_use_fragments option is %sspecified\n",
-			SQUASHFS_ALWAYS_FRAGMENTS(sBlk.s.flags) ? "" : "not ");
-	} else
-		printf("Fragments are not supported by the filesystem\n");
+		if(SQUASHFS_NO_FRAGMENTS(sBlk.s.flags))
+			printf("Fragments are not stored\n");
+		else {
+			printf("Fragments are %scompressed\n",
+				SQUASHFS_UNCOMPRESSED_FRAGMENTS(sBlk.s.flags) ?
+				"un" : "");
+			printf("Always_use_fragments option is %sspecified\n",
+				SQUASHFS_ALWAYS_FRAGMENTS(sBlk.s.flags) ? "" :
+				"not ");
+		}
+	}
+
+	if(sBlk.s.s_major == 4) {
+		if(SQUASHFS_NO_XATTRS(sBlk.s.flags))
+			printf("Xattrs are not stored\n");
+		else
+			printf("Xattrs are %scompressed\n",
+				SQUASHFS_UNCOMPRESSED_XATTRS(sBlk.s.flags) ?
+				"un" : "");
+	}
+
+	if(sBlk.s.s_major < 4)
+			printf("Check data is %spresent in the filesystem\n",
+				SQUASHFS_CHECK_DATA(sBlk.s.flags) ? "" :
+				"not ");
 
 	if(sBlk.s.s_major > 1)
 		printf("Duplicates are %sremoved\n",
 			SQUASHFS_DUPLICATES(sBlk.s.flags) ? "" : "not ");
 	else
 		printf("Duplicates are removed\n");
+
 	if(sBlk.s.s_major > 1)
 		printf("Number of fragments %d\n", sBlk.s.fragments);
+
 	printf("Number of inodes %d\n", sBlk.s.inodes);
+
 	if(sBlk.s.s_major == 4)
 		printf("Number of ids %d\n", sBlk.s.no_ids);
 	else {
@@ -1404,6 +1434,7 @@
 	TRACE("sBlk.s.inode_table_start 0x%llx\n", sBlk.s.inode_table_start);
 	TRACE("sBlk.s.directory_table_start 0x%llx\n",
 		sBlk.s.directory_table_start);
+
 	if(sBlk.s.s_major == 4) {
 		TRACE("sBlk.s.id_table_start 0x%llx\n", sBlk.s.id_table_start);
 		TRACE("sBlk.s.xattr_id_table_start 0x%llx\n",
@@ -1412,6 +1443,7 @@
 		TRACE("sBlk.uid_start 0x%llx\n", sBlk.uid_start);
 		TRACE("sBlk.guid_start 0x%llx\n", sBlk.guid_start);
 	}
+
 	if(sBlk.s.s_major > 1)
 		TRACE("sBlk.s.fragment_table_start 0x%llx\n\n",
 			sBlk.s.fragment_table_start);
@@ -1421,12 +1453,12 @@
 int read_super(char *source)
 {
 	squashfs_super_block_3 sBlk_3;
-	squashfs_super_block sBlk_4;
+	struct squashfs_super_block sBlk_4;
 
 	/*
 	 * Try to read a Squashfs 4 superblock
 	 */
-	read_fs_bytes(fd, SQUASHFS_START, sizeof(squashfs_super_block),
+	read_fs_bytes(fd, SQUASHFS_START, sizeof(struct squashfs_super_block),
 		&sBlk_4);
 	swap = sBlk_4.s_magic != SQUASHFS_MAGIC;
 	SQUASHFS_INSWAP_SUPER_BLOCK(&sBlk_4);
@@ -1551,7 +1583,8 @@
 	FILE *fd;
 	char name[16384];
 
-	if((fd = fopen(filename, "r")) == NULL)
+	fd = fopen(filename, "r");
+	if(fd == NULL)
 		EXIT_UNSQUASH("Could not open %s, because %s\n", filename,
 			strerror(errno));
 
@@ -1604,7 +1637,7 @@
 	while(1) {
 		struct squashfs_file *file = queue_get(to_writer);
 		int file_fd;
-		int hole = 0;
+		long long hole = 0;
 		int failed = FALSE;
 		int error;
 
@@ -1700,7 +1733,7 @@
 		struct cache_entry *entry = queue_get(to_deflate);
 		int error, res;
 
-		res = comp->uncompress(tmp, entry->data,
+		res = compressor_uncompress(comp, tmp, entry->data,
 			SQUASHFS_COMPRESSED_SIZE_BLOCK(entry->size), block_size,
 			&error);
 
@@ -1798,7 +1831,8 @@
 #endif
 	}
 
-	if((thread = malloc((3 + processors) * sizeof(pthread_t))) == NULL)
+	thread = malloc((3 + processors) * sizeof(pthread_t));
+	if(thread == NULL)
 		EXIT_UNSQUASH("Out of memory allocating thread descriptors\n");
 	deflator_thread = &thread[3];
 
@@ -1903,7 +1937,7 @@
 
 
 #define VERSION() \
-	printf("unsquashfs version 4.1 (2010/09/19)\n");\
+	printf("unsquashfs version 4.1-CVS (2010/12/31)\n");\
 	printf("copyright (C) 2010 Phillip Lougher "\
 		"<phillip@lougher.demon.co.uk>\n\n");\
     	printf("This program is free software; you can redistribute it and/or"\
@@ -2081,7 +2115,7 @@
 			ERROR("\t-da[ta-queue] <size>\tSet data queue to "
 				"<size> Mbytes.  Default %d\n\t\t\t\tMbytes\n",
 				DATA_BUFFER_DEFAULT);
-			ERROR("\t-fr[ag-queue] <size>\tSet fagment queue to "
+			ERROR("\t-fr[ag-queue] <size>\tSet fragment queue to "
 				"<size> Mbytes.  Default %d\n\t\t\t\t Mbytes\n",
 				FRAGMENT_BUFFER_DEFAULT);
 			ERROR("\t-r[egex]\t\ttreat extract names as POSIX "
@@ -2126,16 +2160,20 @@
 	data_buffer_size <<= 20 - block_log;
 	initialise_threads(fragment_buffer_size, data_buffer_size);
 
-	if((fragment_data = malloc(block_size)) == NULL)
+	fragment_data = malloc(block_size);
+	if(fragment_data == NULL)
 		EXIT_UNSQUASH("failed to allocate fragment_data\n");
 
-	if((file_data = malloc(block_size)) == NULL)
+	file_data = malloc(block_size);
+	if(file_data == NULL)
 		EXIT_UNSQUASH("failed to allocate file_data");
 
-	if((data = malloc(block_size)) == NULL)
+	data = malloc(block_size);
+	if(data == NULL)
 		EXIT_UNSQUASH("failed to allocate data\n");
 
-	if((created_inode = malloc(sBlk.s.inodes * sizeof(char *))) == NULL)
+	created_inode = malloc(sBlk.s.inodes * sizeof(char *));
+	if(created_inode == NULL)
 		EXIT_UNSQUASH("failed to allocate created_inode\n");
 
 	memset(created_inode, 0, sBlk.s.inodes * sizeof(char *));
diff -aurN squashfs4.1.old/squashfs-tools/unsquashfs.h squashfs4.1.new/squashfs-tools/unsquashfs.h
--- squashfs4.1.old/squashfs-tools/unsquashfs.h	2010-08-25 18:12:13.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/unsquashfs.h	2010-12-31 21:32:17.000000000 +0000
@@ -54,7 +54,6 @@
 #endif
 
 #include "squashfs_fs.h"
-#include "global.h"
 
 #ifdef SQUASHFS_TRACE
 #define TRACE(s, args...) \
diff -aurN squashfs4.1.old/squashfs-tools/unsquashfs_xattr.c squashfs4.1.new/squashfs-tools/unsquashfs_xattr.c
--- squashfs4.1.old/squashfs-tools/unsquashfs_xattr.c	2010-08-25 17:11:22.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/unsquashfs_xattr.c	2010-11-12 04:52:46.000000000 +0000
@@ -25,7 +25,7 @@
 #include "unsquashfs.h"
 #include "xattr.h"
 
-#include <attr/xattr.h>
+#include <sys/xattr.h>
 
 extern int root_process;
 
diff -aurN squashfs4.1.old/squashfs-tools/xattr.c squashfs4.1.new/squashfs-tools/xattr.c
--- squashfs4.1.old/squashfs-tools/xattr.c	2010-08-24 01:37:37.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/xattr.c	2010-12-31 21:32:17.000000000 +0000
@@ -34,10 +34,9 @@
 #include <dirent.h>
 #include <string.h>
 #include <stdlib.h>
-#include <attr/xattr.h>
+#include <sys/xattr.h>
 
 #include "squashfs_fs.h"
-#include "global.h"
 #include "squashfs_swap.h"
 #include "mksquashfs.h"
 #include "xattr.h"
@@ -92,12 +91,12 @@
 
 /* helper functions from mksquashfs.c */
 extern unsigned short get_checksum(char *, int, unsigned short);
-extern void write_destination(int, long long, int, char *);
+extern void write_destination(int, long long, int, void *);
 extern long long generic_write_table(int, void *, int, void *, int);
 extern int mangle(char *, char *, int, int, int, int);
 
 /* helper functions and definitions from read_xattrs.c */
-extern int read_xattrs_from_disk(int, squashfs_super_block *);
+extern int read_xattrs_from_disk(int, struct squashfs_super_block *);
 extern struct xattr_list *get_xattr(int, unsigned int *);
 extern struct prefix prefix_table[];
 
@@ -219,6 +218,10 @@
 			break;
 		}
 		xattr_list[i].vsize = vsize;
+
+		TRACE("read_xattrs_from_system: filename %s, xattr name %s,"
+			" vsize %d\n", filename, xattr_list[i].full_name,
+			xattr_list[i].vsize);
 	}
 	free(xattr_names);
 	*xattrs = xattr_list;
@@ -472,7 +475,7 @@
 	/*
 	 * Write compressed xattr table to file system
 	 */
-	write_destination(fd, bytes, xattr_bytes, (char *) xattr_table);
+	write_destination(fd, bytes, xattr_bytes, xattr_table);
         bytes += xattr_bytes;
 
 	/*
@@ -655,7 +658,7 @@
  * take place against the xattrs already in the file system being appended to,
  * and ensures the pre-existing xattrs are written out along with any new xattrs
  */
-int get_xattrs(int fd, squashfs_super_block *sBlk)
+int get_xattrs(int fd, struct squashfs_super_block *sBlk)
 {
 	int ids, res, i, id;
 	unsigned int count;
diff -aurN squashfs4.1.old/squashfs-tools/xattr.h squashfs4.1.new/squashfs-tools/xattr.h
--- squashfs4.1.old/squashfs-tools/xattr.h	2010-08-29 00:20:32.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/xattr.h	2010-12-31 21:21:26.000000000 +0000
@@ -64,17 +64,17 @@
 extern int generate_xattrs(int, struct xattr_list *);
 
 #ifdef XATTR_SUPPORT
-extern int get_xattrs(int, squashfs_super_block *);
+extern int get_xattrs(int, struct squashfs_super_block *);
 extern int read_xattrs(void *);
 extern long long write_xattrs();
 extern int save_xattrs();
 extern void restore_xattrs();
 extern unsigned int xattr_bytes, total_xattr_bytes;
 extern void write_xattr(char *, unsigned int);
-extern int read_xattrs_from_disk(int, squashfs_super_block *);
+extern int read_xattrs_from_disk(int, struct squashfs_super_block *);
 extern struct xattr_list *get_xattr(int, unsigned int *);
 #else
-static inline int get_xattrs(int fd, squashfs_super_block *sBlk)
+static inline int get_xattrs(int fd, struct squashfs_super_block *sBlk)
 {
 	if(sBlk->xattr_id_table_start != SQUASHFS_INVALID_BLK) {
 		fprintf(stderr, "Xattrs in filesystem! These are not "
@@ -113,7 +113,7 @@
 }
 
 
-static inline int read_xattrs_from_disk(int fd, squashfs_super_block *sBlk)
+static inline int read_xattrs_from_disk(int fd, struct squashfs_super_block *sBlk)
 {
 	if(sBlk->xattr_id_table_start != SQUASHFS_INVALID_BLK) {
 		fprintf(stderr, "Xattrs in filesystem! These are not "
diff -aurN squashfs4.1.old/squashfs-tools/xz_wrapper.c squashfs4.1.new/squashfs-tools/xz_wrapper.c
--- squashfs4.1.old/squashfs-tools/xz_wrapper.c	2010-02-01 02:48:01.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/xz_wrapper.c	2010-12-31 08:16:21.000000000 +0000
@@ -17,69 +17,311 @@
  * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  *
  * xz_wrapper.c
+ *
+ * Support for XZ (LZMA2) compression using XZ Utils liblzma
+ * http://tukaani.org/xz/
  */
 
 #include <stdio.h>
 #include <string.h>
+#include <stdlib.h>
 #include <lzma.h>
 
-#define LZMA_PROPS_SIZE 5
-#define LZMA_UNCOMP_SIZE 8
-#define LZMA_HEADER_SIZE (LZMA_PROPS_SIZE + LZMA_UNCOMP_SIZE)
+#include "squashfs_fs.h"
+#include "xz_wrapper.h"
+#include "compressor.h"
+
+static struct bcj bcj[] = {
+	{ "x86", LZMA_FILTER_X86, 0 },
+	{ "powerpc", LZMA_FILTER_POWERPC, 0 },
+	{ "ia64", LZMA_FILTER_IA64, 0 },
+	{ "arm", LZMA_FILTER_ARM, 0 },
+	{ "armthumb", LZMA_FILTER_ARMTHUMB, 0 },
+	{ "sparc", LZMA_FILTER_SPARC, 0 },
+	{ NULL, LZMA_VLI_UNKNOWN, 0 }
+};
+
+static struct comp_opts comp_opts;
+
+static int filter_count = 1;
+static int dictionary_size = 0;
+static float dictionary_percent = 0;
+static int defaults;
 
-#define LZMA_OPTIONS 5
-#define MEMLIMIT (32 * 1024 * 1024)
 
-int lzma_compress(void **dummy, void *dest, void *src,  int size,
-	int block_size, int *error)
+static int xz_options(char *argv[], int argc)
 {
-	unsigned char *d = (unsigned char *) dest;
-	lzma_options_lzma opt;
-	lzma_stream strm = LZMA_STREAM_INIT;
-	int res;
-
-	lzma_lzma_preset(&opt, LZMA_OPTIONS);
-	opt.dict_size = block_size;
-	res = lzma_alone_encoder(&strm, &opt);
-	if(res != LZMA_OK) {
-		lzma_end(&strm);
+	int i;
+	char *name;
+
+	if(strcmp(argv[0], "-Xbcj") == 0) {
+		if(argc < 2) {
+			fprintf(stderr, "xz: -Xbcj missing filter\n");
+			goto failed;
+		}
+
+		name = argv[1];
+		while(name[0] != '\0') {
+			for(i = 0; bcj[i].name; i++) {
+				int n = strlen(bcj[i].name);
+				if((strncmp(name, bcj[i].name, n) == 0) &&
+						(name[n] == '\0' ||
+						 name[n] == ',')) {
+					if(bcj[i].selected == 0) {
+				 		bcj[i].selected = 1;
+						filter_count++;
+					}
+					name += name[n] == ',' ? n + 1 : n;
+					break;
+				}
+			}
+			if(bcj[i].name == NULL) {
+				fprintf(stderr, "xz: -Xbcj unrecognised "
+					"filter\n");
+				goto failed;
+			}
+		}
+	
+		return 1;
+	} else if(strcmp(argv[0], "-Xdict-size") == 0) {
+		char *b;
+		float size;
+
+		if(argc < 2) {
+			fprintf(stderr, "xz: -Xdict-size missing dict-size\n");
+			goto failed;
+		}
+
+		size = strtof(argv[1], &b);
+		if(*b == '%') {
+			if(size <= 0 || size > 100) {
+				fprintf(stderr, "xz: -Xdict-size percentage "
+					"should be 0 < dict-size <= 100\n");
+				goto failed;
+			}
+
+			dictionary_percent = size;
+			dictionary_size = 0;
+		} else {
+			if((float) ((int) size) != size) {
+				fprintf(stderr, "xz: -Xdict-size can't be "
+					"fractional unless a percentage of the"
+					" block size\n");
+				goto failed;
+			}
+
+			dictionary_percent = 0;
+			dictionary_size = (int) size;
+
+			if(*b == 'k' || *b == 'K')
+				dictionary_size *= 1024;
+			else if(*b == 'm' || *b == 'M')
+				dictionary_size *= 1024 * 1024;
+			else if(*b != '\0') {
+				fprintf(stderr, "xz: -Xdict-size invalid "
+					"dict-size\n");
+				goto failed;
+			}
+		}
+
+		return 1;
+	}
+
+	return -1;
+	
+failed:
+	return -2;
+}
+
+
+static int xz_options_post(int block_size)
+{
+	int n;
+
+	if(dictionary_size) {
+		if(dictionary_size > block_size) {
+			fprintf(stderr, "xz: -Xdict-size is larger than "
+				"block_size\n");
+			goto failed;
+		}
+	} else if(dictionary_percent)
+		dictionary_size = block_size * dictionary_percent / 100;
+	else
+		dictionary_size = block_size;
+
+	if(dictionary_size < 4096) {
+		fprintf(stderr, "xz: -Xdict-size should be 4096 bytes or "
+			"larger\n");
 		goto failed;
 	}
 
-	strm.next_out = dest;
-	strm.avail_out = block_size;
-	strm.next_in = src;
-	strm.avail_in = size;
+	/*
+	 * dictionary_size must be storable in xz header as either 2^n or as
+	 * 2^n+2^(n+1)
+	 */
+	n = ffs(dictionary_size) - 1;
+	if(dictionary_size != (1 << n) && 
+			dictionary_size != ((1 << n) + (1 << (n + 1)))) {
+		fprintf(stderr, "xz: -Xdict-size is an unsupported value, "
+			"dict-size must be storable in xz header\n");
+		fprintf(stderr, "as either 2^n or as 2^n+2^(n+1).  Example "
+			"dict-sizes are 75%%, 50%%, 37.5%%, 25%%,\n");
+		fprintf(stderr, "or 32K, 16K, 8K etc.\n");
+		goto failed;
+	}
 
-	res = lzma_code(&strm, LZMA_FINISH);
-	lzma_end(&strm);
+	defaults = filter_count == 1 && dictionary_size == block_size;
 
-	if(res == LZMA_STREAM_END) {
-		/*
-	 	 * Fill in the 8 byte little endian uncompressed size field in
-		 * the LZMA header.  8 bytes is excessively large for squashfs
-		 * but this is the standard LZMA header and which is expected by
-		 * the kernel code
-	 	 */
+	return 0;
+
+failed:
+	return -1;
+}
+
+
+static void *xz_dump_options(int *size)
+{
+	int flags = 0, i;
+
+	/*
+	 * don't store compressor specific options in file system if the
+	 * default options are being used - no compressor options in the
+	 * file system means the default options are always assumed
+	 */
+	if(defaults)
+		return NULL;
+
+	for(i = 0; bcj[i].name; i++)
+		flags |= bcj[i].selected << i;
+
+	comp_opts.dictionary_size = dictionary_size;
+	comp_opts.flags = flags;
+
+	SQUASHFS_INSWAP_COMP_OPTS(&comp_opts);
+
+	*size = sizeof(comp_opts);
+	return &comp_opts;
+}
+
+
+static int xz_extract_options(int block_size, void *buffer, int size)
+{
+	struct comp_opts *comp_opts = buffer;
+	int flags, i;
 
-		d[LZMA_PROPS_SIZE] = size & 255;
-		d[LZMA_PROPS_SIZE + 1] = (size >> 8) & 255;
-		d[LZMA_PROPS_SIZE + 2] = (size >> 16) & 255;
-		d[LZMA_PROPS_SIZE + 3] = (size >> 24) & 255;
-		d[LZMA_PROPS_SIZE + 4] = 0;
-		d[LZMA_PROPS_SIZE + 5] = 0;
-		d[LZMA_PROPS_SIZE + 6] = 0;
-		d[LZMA_PROPS_SIZE + 7] = 0;
+	if(size == 0) {
+		/* set defaults */
+		dictionary_size = block_size;
+		flags = 0;
+	} else {
+		SQUASHFS_INSWAP_COMP_OPTS(&comp_opts);
 
-		return (int) strm.total_out;
+		dictionary_size = comp_opts->dictionary_size;
+		flags = comp_opts->flags;
 	}
 
-	if(res == LZMA_OK)
+	for(i = 0; bcj[i].name; i++)
+		bcj[i].selected = (flags >> i) & 1;
+
+	return 0;
+}
+
+
+static int xz_init(void **strm, int block_size, int datablock)
+{
+	int i, j, filters = datablock ? filter_count : 1;
+	struct filter *filter = malloc(filters * sizeof(struct filter));
+	struct xz_stream *stream;
+
+	if(filter == NULL)
+		goto failed;
+
+	stream = *strm = malloc(sizeof(struct xz_stream));
+	if(stream == NULL)
+		goto failed2;
+
+	stream->filter = filter;
+	stream->filters = filters;
+
+	memset(filter, 0, filters * sizeof(struct filter));
+
+	stream->dictionary_size = datablock ? dictionary_size :
+		dictionary_size < SQUASHFS_METADATA_SIZE ?
+		dictionary_size : SQUASHFS_METADATA_SIZE;
+
+	filter[0].filter[0].id = LZMA_FILTER_LZMA2;
+	filter[0].filter[0].options = &stream->opt;
+	filter[0].filter[1].id = LZMA_VLI_UNKNOWN;
+
+	for(i = 0, j = 1; datablock && bcj[i].name; i++) {
+		if(bcj[i].selected) {
+			filter[j].buffer = malloc(block_size);
+			if(filter[j].buffer == NULL)
+				goto failed3;
+			filter[j].filter[0].id = bcj[i].id;
+			filter[j].filter[1].id = LZMA_FILTER_LZMA2;
+			filter[j].filter[1].options = &stream->opt;
+			filter[j].filter[2].id = LZMA_VLI_UNKNOWN;
+			j++;
+		}
+	}
+
+	return 0;
+
+failed3:
+	for(i = 1; i < filters; i++)
+		free(filter[i].buffer);
+	free(stream);
+
+failed2:
+	free(filter);
+
+failed:
+	return -1;
+}
+
+
+static int xz_compress(void *strm, void *dest, void *src,  int size,
+	int block_size, int *error)
+{
+	int i;
+        lzma_ret res = 0;
+	struct xz_stream *stream = strm;
+	struct filter *selected = NULL;
+
+	stream->filter[0].buffer = dest;
+
+	for(i = 0; i < stream->filters; i++) {
+		struct filter *filter = &stream->filter[i];
+
+        	if(lzma_lzma_preset(&stream->opt, LZMA_PRESET_DEFAULT))
+                	goto failed;
+
+		stream->opt.dict_size = stream->dictionary_size;
+
+		filter->length = 0;
+		res = lzma_stream_buffer_encode(filter->filter,
+			LZMA_CHECK_CRC32, NULL, src, size, filter->buffer,
+			&filter->length, block_size);
+	
+		if(res == LZMA_OK) {
+			if(!selected || selected->length > filter->length)
+				selected = filter;
+		} else if(res != LZMA_BUF_ERROR)
+			goto failed;
+	}
+
+	if(!selected)
 		/*
 	 	 * Output buffer overflow.  Return out of buffer space
 	 	 */
 		return 0;
 
+	if(selected->buffer != dest)
+		memcpy(dest, selected->buffer, selected->length);
+
+	return (int) selected->length;
+
 failed:
 	/*
 	 * All other errors return failure, with the compressor
@@ -90,49 +332,52 @@
 }
 
 
-int lzma_uncompress(void *dest, void *src, int size, int block_size,
+static int xz_uncompress(void *dest, void *src, int size, int block_size,
 	int *error)
 {
-	lzma_stream strm = LZMA_STREAM_INIT;
-	int uncompressed_size = 0, res;
-	unsigned char lzma_header[LZMA_HEADER_SIZE];
-
-	res = lzma_alone_decoder(&strm, MEMLIMIT);
-	if(res != LZMA_OK) {
-		lzma_end(&strm);
-		goto failed;
-	}
+	size_t src_pos = 0;
+	size_t dest_pos = 0;
+	uint64_t memlimit = MEMLIMIT;
 
-	memcpy(lzma_header, src, LZMA_HEADER_SIZE);
-	uncompressed_size = lzma_header[LZMA_PROPS_SIZE] |
-		(lzma_header[LZMA_PROPS_SIZE + 1] << 8) |
-		(lzma_header[LZMA_PROPS_SIZE + 2] << 16) |
-		(lzma_header[LZMA_PROPS_SIZE + 3] << 24);
-	memset(lzma_header + LZMA_PROPS_SIZE, 255, LZMA_UNCOMP_SIZE);
-
-	strm.next_out = dest;
-	strm.avail_out = block_size;
-	strm.next_in = lzma_header;
-	strm.avail_in = LZMA_HEADER_SIZE;
+	lzma_ret res = lzma_stream_buffer_decode(&memlimit, 0, NULL,
+			src, &src_pos, size, dest, &dest_pos, block_size);
 
-	res = lzma_code(&strm, LZMA_RUN);
-
-	if(res != LZMA_OK || strm.avail_in != 0) {
-		lzma_end(&strm);
-		goto failed;
-	}
+	*error = res;
+	return res == LZMA_OK && size == (int) src_pos ? (int) dest_pos : -1;
+}
 
-	strm.next_in = src + LZMA_HEADER_SIZE;
-	strm.avail_in = size - LZMA_HEADER_SIZE;
 
-	res = lzma_code(&strm, LZMA_FINISH);
-	lzma_end(&strm);
+void xz_usage()
+{
+	fprintf(stderr, "\t  -Xbcj filter1,filter2,...,filterN\n");
+	fprintf(stderr, "\t\tCompress using filter1,filter2,...,filterN in");
+	fprintf(stderr, " turn\n\t\t(in addition to no filter), and choose");
+	fprintf(stderr, " the best compression.\n");
+	fprintf(stderr, "\t\tAvailable filters: x86, arm, armthumb,");
+	fprintf(stderr, " powerpc, sparc, ia64\n");
+	fprintf(stderr, "\t  -Xdict-size <dict-size>\n");
+	fprintf(stderr, "\t\tUse <dict-size> as the XZ dictionary size.  The");
+	fprintf(stderr, " dictionary size\n\t\tcan be specified as a");
+	fprintf(stderr, " percentage of the block size, or as an\n\t\t");
+	fprintf(stderr, "absolute value.  The dictionary size must be less");
+	fprintf(stderr, " than or equal\n\t\tto the block size and 4096 bytes");
+	fprintf(stderr, " or larger.  It must also be\n\t\tstorable in the xz");
+	fprintf(stderr, " header as either 2^n or as 2^n+2^(n+1).\n\t\t");
+	fprintf(stderr, "Example dict-sizes are 75%%, 50%%, 37.5%%, 25%%, or");
+	fprintf(stderr, " 32K, 16K, 8K\n\t\tetc.\n");
+}
 
-	if(res == LZMA_STREAM_END || (res == LZMA_OK &&
-		strm.total_out >= uncompressed_size && strm.avail_in == 0))
-		return uncompressed_size;
 
-failed:
-	*error = res;
-	return -1;
-}
+struct compressor xz_comp_ops = {
+	.init = xz_init,
+	.compress = xz_compress,
+	.uncompress = xz_uncompress,
+	.options = xz_options,
+	.options_post = xz_options_post,
+	.dump_options = xz_dump_options,
+	.extract_options = xz_extract_options,
+	.usage = xz_usage,
+	.id = XZ_COMPRESSION,
+	.name = "xz",
+	.supported = 1
+};
diff -aurN squashfs4.1.old/squashfs-tools/xz_wrapper.h squashfs4.1.new/squashfs-tools/xz_wrapper.h
--- squashfs4.1.old/squashfs-tools/xz_wrapper.h	1970-01-01 00:00:00.000000000 +0000
+++ squashfs4.1.new/squashfs-tools/xz_wrapper.h	2010-12-31 08:04:04.000000000 +0000
@@ -0,0 +1,71 @@
+#ifndef XZ_WRAPPER_H
+#define XZ_WRAPPER_H
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2010
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * xz_wrapper.h
+ *
+ */
+
+#ifndef linux
+#define __BYTE_ORDER BYTE_ORDER
+#define __BIG_ENDIAN BIG_ENDIAN
+#define __LITTLE_ENDIAN LITTLE_ENDIAN
+#else
+#include <endian.h>
+#endif
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+extern unsigned int inswap_le32(unsigned int);
+
+#define SQUASHFS_INSWAP_COMP_OPTS(s) { \
+	(s)->dictionary_size = inswap_le32((s)->dictionary_size); \
+	(s)->flags = inswap_le32((s)->flags); \
+}
+#else
+#define SQUASHFS_INSWAP_COMP_OPTS(s)
+#endif
+
+#define MEMLIMIT (32 * 1024 * 1024)
+
+struct bcj {
+	char	 	*name;
+	lzma_vli	id;
+	int		selected;
+};
+
+struct filter {
+	void		*buffer;
+	lzma_filter	filter[3];
+	size_t		length;
+};
+
+struct xz_stream {
+	struct filter	*filter;
+	int		filters;
+	int		dictionary_size;
+	lzma_options_lzma opt;
+};
+
+struct comp_opts {
+	int dictionary_size;
+	int flags;
+};
+#endif
